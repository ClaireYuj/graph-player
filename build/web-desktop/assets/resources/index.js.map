{"version":3,"sources":["../../file:/F:/openSource/projects/graph-player/assets/resources/Scipts/file:/F:/openSource/projects/graph-player/assets/resources/Scipts/CameraController.ts","../../file:/F:/openSource/projects/graph-player/assets/resources/Scipts/file:/F:/openSource/projects/graph-player/assets/resources/Scipts/CanvasManager.ts","../../file:/F:/openSource/projects/graph-player/assets/resources/Scipts/file:/F:/openSource/projects/graph-player/assets/resources/Scipts/Constant.ts","../../file:/F:/openSource/projects/graph-player/assets/resources/Scipts/data/file:/F:/openSource/projects/graph-player/assets/resources/Scipts/data/CustomEventListener.ts","../../file:/F:/openSource/projects/graph-player/assets/resources/Scipts/data/file:/F:/openSource/projects/graph-player/assets/resources/Scipts/data/Dictionary.ts","../../file:/F:/openSource/projects/graph-player/assets/resources/Scipts/file:/F:/openSource/projects/graph-player/assets/resources/Scipts/Edge.ts","../../file:/F:/openSource/projects/graph-player/assets/resources/Scipts/file:/F:/openSource/projects/graph-player/assets/resources/Scipts/EdgeManager.ts","../../file:/F:/openSource/projects/graph-player/assets/resources/Scipts/file:/F:/openSource/projects/graph-player/assets/resources/Scipts/Graphplayer.ts","../../file:/F:/openSource/projects/graph-player/assets/resources/Scipts/file:/F:/openSource/projects/graph-player/assets/resources/Scipts/JSONReader.ts","../../file:/F:/openSource/projects/graph-player/assets/resources/Scipts/file:/F:/openSource/projects/graph-player/assets/resources/Scipts/LayoutManager.ts","../../file:/F:/openSource/projects/graph-player/assets/resources/Scipts/file:/F:/openSource/projects/graph-player/assets/resources/Scipts/Manager.ts","../../file:/F:/openSource/projects/graph-player/assets/resources/Scipts/file:/F:/openSource/projects/graph-player/assets/resources/Scipts/RelationManager.ts","../../file:/F:/openSource/projects/graph-player/assets/resources/Scipts/file:/F:/openSource/projects/graph-player/assets/resources/Scipts/TableData.ts","../../file:/F:/openSource/projects/graph-player/assets/resources/Scipts/file:/F:/openSource/projects/graph-player/assets/resources/Scipts/UIManager.ts","../../file:/F:/openSource/projects/graph-player/assets/resources/Scipts/file:/F:/openSource/projects/graph-player/assets/resources/Scipts/Vertex.ts","../../file:/F:/openSource/projects/graph-player/assets/resources/Scipts/file:/F:/openSource/projects/graph-player/assets/resources/Scipts/VertexManager.ts"],"names":["ccclass","_decorator","property","Camera","Vec3","args","_this","_initializerDefineProperty","smoothZoomIntervals","originalOffsetFactor","_inheritsLoose","_proto","onLoad","camera","find","getComponent","originalOffset","near","this","length","clone","normalize","focusOn","node","recordCurrentOffset","targetPosition","getWorldPosition","targetOffset","currentOffset","multiplyScalar","tween","to","worldPosition","add","easing","start","rotateOnVertex","target","center","angle","axis","UP","rotateQuat","Quat","dir","rotated","subtract","rad","misc","degreesToRadians","fromAxisAngle","transformQuat","resetPosition","position","Manager","Instance","vertexManager","rootNode","rotation","identity","canvasManager","cameraRotateOffset","currentCentralNode","chosenVertex","Component","configurable","enumerable","writable","initializer","type","Node","leftClickCount","lastClickTime","doubleClickDelay","_zoomSpeed","cameraMove","cameraRotateAroundVertex","previousMousePosition","previousMousePositionVec3","dragMoveSpeed","dragRotateSpeed","dragRotationQuat","dragRotateEuler","input","on","Input","EventType","MOUSE_DOWN","onMouseDown","MOUSE_UP","onMouseUp","MOUSE_MOVE","onMouseMove","MOUSE_WHEEL","onMouseWheel","resetCanvas","event","dx","getDeltaX","dy","getDeltaY","newPosition","cameraController","x","y","z","currentMousePosition","getLocation","angleX","angleY","cameraPos","targetPos","rotatedPosX","rotatedPosY","RIGHT","lookAt","getButton","EventMouse","BUTTON_RIGHT","chooseVertexOrEdgeAtMouse","BUTTON_MIDDLE","BUTTON_LEFT","set","getLocationX","getLocationY","UIManager","tagOrderChoiceBar","active","dropDownBarLayout","scrollY","getScrollY","newCameraPos","math","scaleAndAdd","forward","onDestroy","off","createVertexAtMouse","ray","geometry","Ray","screenPointToRay","PhysicsSystem","instance","raycastClosest","result","raycastClosestResult","collider","Vertex","childVertex","createNodeAround","edgeManager","createEdgeWithStartAndEnd","returnFocusToNormalEdge","centralVertex","returnFocusToNormalVertex","chooseOneNormalVertexToFocus","showVertexDetails","Edge","chosenEdgeNode","chooseNormalEdge","showEdgeDetails","cleanCanvas","destroyAllChildren","destroyAllEdges","isNodeInfoEnable","nodeInfoBar","initiateOriginalVertex","DEFAULT","MOUSE","EDGE","VERTEX","CustomEventListener","eventName","cb","handle","data","func","push","list","i","splice","dispatchEvent","apply","key","value","CCString","Object","CCInteger","Boolean","startNode","endNode","startVertex","endVertex","end","setWorldPosition","distance","setScale","right","quat","rotationTo","setRotation","srcID","getVertexID","dstID","addAllThisVertexEdgeInfoOnEdge","vertexEdgeDic","addEdgeInfoOnVertex","edgeVertexDic","edgeID","getEdgeID","changeEdgeMaterialToFocused","focusMaterial","MeshRenderer","getMaterial","setMaterial","returnToInitialMaterial","initialMaterial","setAttribute","attribute","hasOwnProperty","edgeName","relationManager","setEdgeID","setRichInfo","addRichInfo","printNestedJSON","properties","rank","obj","parentKey","newKey","Prefab","edgeNode","instantiate","edgePrefab","setParent","cleanAndDisableInfoBar","removeLayoutFlags","children","isLayouted","removeAllChildren","JSONReader","getJSONResponse","changeJSONResponseUrl","url","jsonResponseUrl","startWithTableDetails","xhr","XMLHttpRequest","console","log","onreadystatechange","readyState","status","jsonString","JSON","parse","responseText","transTabletoVertexAndEdge","open","setRequestHeader","send","TableData","putJSONtoModel","filename","path","loadJson","tables","_this2","callback","resources","load","err","res","error","message","json","getCookie","name","parts","document","cookie","split","decodeURIComponent","pop","shift","fetch","then","response","_this3","edges","_edgesParsedList","vertices","_verticesParsedList","edge","isStartVertexExists","existVertex","vid","isEndVertexExits","existEdge","getVertexNodeByVID","increaseVertexDegree","increaseTagDegree","createStartNode","tagsNodeList","centerToTag0Radius","tagsNodeRadius","nodesLayerRadiusInterval","Math","PI","classifyNodeByTag","tagNodeCount","vertexTagSet","tag","getChildByName","newTagNode","parent","vertexTag","tags","adjustOrderOfTags","tagsName","tagName","reLayoutByTags","nodes","angleStep","cos","sin","tag0Node","updateEndVertexAndEdge","edgeNum","edgesSetOfVertex","areAllEdgesLayouted","normal","cross","ZERO","initialVector","selfAngleStep","initialAngle","selfAngle","angleBiasBetweenTags","getTagIndex","tmp_normal","tmp_initialVector","vectorWithRadius","getElementIndex","quaternion","materialReallocated","tagIndex","tagNode","setMaterialCode","changeMaterial","index","element","getTags","tagList","CameraController","VertexManager","CanvasManager","EdgeManager","RelationManager","LayoutManager","physics","enable","layoutManager","Set","tagDegreeDic","tagDegreeDicLength","vertexIDBox","edgeIDBox","setVertexID","s","vertexCount","removeVertex","has","removeEdge","edgeCount","resetVertexAndEdgeBox","clear","vertexID","vertex","map","edgeData","vertexData","Button","EditBox","RichText","Layout","clickEventHandler","EventHandler","vertexIDLabelManager","vertexIDLabelPrefab","BtnWidth","BtnLength","timer","isEnteredTagOrderChoiceBar","nodeInfoPrefix","nodeInfoSuffix","RefreshCanvas","createCanvasFromJSONFile","method","jsonFilename","createCanvasFromJSONEditBox","string","createVertex","changeLayout","finalTagOrder","finalTagOrderList","nodeInfoText","prefab","refreshClickEventHandler","refreshBtn","component","handler","clickEvents","createCanvasFromJSONFileEventHandler","createCanvasFromJSONButton","customEventData","layoutEventHandler","layoutBtn","MOUSE_ENTER","chooseLayoutBtn","bind","MOUSE_LEAVE","onLayoutBtnMouseLeave","onMouseEnterTagOrderChoiceBar","onMouseLeaveTagOrderChoiceBar","createVertexEventHandler","createVertexBtn","deleteVertexEventHandler","deleteVertexBtn","info","cleanRichInfo","cleanTagOrderChoices","Array","from","tagOrderList","keys","tagOrderNum","UITransform","setContentSize","tagOrderChoiceBtnList","tagOrderBtn","tagOrderChoiceBtnPrefab","setPosition","Label","tagOrderChoiceHandler","getPermutationByTagDegree","join","firstElement","dic","arr","j","key1","key2","generatePermutations","current","includes","slice","clearTimeout","setTimeout","child","destroy","setVeretxIDLabel","Number","CCBoolean","idLabel","addTag","entry","setVertexId","materialCode","code","materialIndex","tmpMaterial","getMaterialCode","degree","isTransformView","vertexMaterialCount","vertexRadius","vertexPrefab","initialMaterialCode","floor","random","chosenNode","traverseNodesChildren","forEach"],"mappings":"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","file":"all.js","sourcesContent":["import { _decorator, Camera, Component, find, input, Node, Vec3, tween, Scheduler,Quat, misc} from 'cc';\r\nimport { Manager } from './Manager';\r\nconst { ccclass, property } = _decorator;\r\n\r\n@ccclass('CameraController')\r\nexport class CameraController extends Component {\r\n    // @property(Node)\r\n    // centralNode:Node = find(\"Manager/VertexManager/Vertex\");\r\n    @property(Camera)\r\n    mainCamera:Camera;\r\n    @property(Vec3)\r\n    originalOffset:Vec3;\r\n    @property(Vec3)\r\n    currentOffset:Vec3;\r\n    @property(Camera)\r\n    public camera: Camera;\r\n\r\n    private smoothZoomIntervals = 0.42;\r\n    private originalOffsetFactor:number;\r\n\r\n    onLoad() {\r\n        \r\n        this.camera = find(\"Main Camera\").getComponent(Camera);\r\n        this.originalOffset = new Vec3(0,0,2);\r\n        this.camera.near = 0.01;\r\n        this.originalOffsetFactor = this.originalOffset.length() / this.originalOffset.clone().normalize().length();\r\n        //console.log(\"camera offset factor:\",this.originalOffsetFactor);\r\n\r\n    }\r\n\r\n\r\n    focusOn(node: Node) {\r\n        this.recordCurrentOffset();\r\n        let targetPosition = node.getWorldPosition();\r\n        let targetOffset = this.currentOffset.clone().normalize().multiplyScalar(this.originalOffsetFactor);\r\n\r\n    \r\n        tween(this.camera.node)\r\n            .to(this.smoothZoomIntervals, { \r\n                worldPosition: targetPosition.clone().add(targetOffset),\r\n            }\r\n                , { easing: 'smooth' })\r\n            .start();\r\n        \r\n\r\n        \r\n\r\n    }\r\n\r\n    rotateOnVertex(target: Vec3, center: Vec3, angle: number, axis: Vec3 = Vec3.UP): Vec3{\r\n        let rotateQuat = new Quat();\r\n        let dir = new Vec3();\r\n        let rotated = new Vec3();\r\n        Vec3.subtract(dir, target, center);\r\n        let rad = misc.degreesToRadians(angle);\r\n        Quat.fromAxisAngle(rotateQuat, axis, rad);\r\n        Vec3.transformQuat(rotated, dir, rotateQuat);\r\n        Vec3.add(rotated, center, rotated);\r\n        return rotated;\r\n    }\r\n\r\n    resetPosition(){\r\n        \r\n        this.camera.node.position = Manager.Instance().vertexManager.rootNode.position.clone().add(this.originalOffset);\r\n        this.camera.node.rotation =  Quat.identity(new Quat());\r\n    }\r\n\r\n    /**\r\n     * record the offset between tmp central node(current central node)\r\n     */\r\n    public recordCurrentOffset(){\r\n        // this.currentOffset = this.camera.node.getWorldPosition().clone().subtract(Manager.Instance().vertexManager.currentCentralNode.getWorldPosition());\r\n        this.currentOffset = Manager.Instance().canvasManager.cameraRotateOffset.clone().subtract(Manager.Instance().vertexManager.currentCentralNode.getWorldPosition());\r\n        Manager.Instance().vertexManager.currentCentralNode = Manager.Instance().vertexManager.chosenVertex;\r\n    }\r\n\r\n\r\n\r\n}\r\n","import {  _decorator, Component, input,Input,EventMouse,  geometry, Node, director, tween, PhysicsSystem, Vec3,Vec2, Camera,math, find, Quat } from 'cc';\r\nimport { Vertex } from './Vertex';\r\nimport { Manager } from './Manager';\r\nimport { Edge } from './Edge';\r\n\r\n\r\nconst { ccclass, property } = _decorator;\r\n\r\n@ccclass('CanvasManager')\r\nexport class CanvasManager extends Component {\r\n\r\n\r\n    @property({ type:Node})\r\n    public centralVertex:Node = null;\r\n    \r\n    // mouse-left parameter\r\n\r\n    public leftClickCount: number = 0; \r\n    private lastClickTime: number = 0;\r\n    private doubleClickDelay: number = 0.3; // double-click intervals of mouse-left\r\n\r\n\r\n    // mouse wheel parameter\r\n    private _zoomSpeed: number = 0.00009; // zoom speed of mouse wheel\r\n\r\n    // mouse movement\r\n\r\n    // private isMouseDragging = false;\r\n    private cameraMove = false;\r\n    private cameraRotateAroundVertex = false;\r\n    public cameraRotateOffset: Vec3 = new Vec3(); // the offset on rotating(tranform from Quat to Vec3)\r\n    private previousMousePosition: Vec2 = null;\r\n    private previousMousePositionVec3: Vec3 = new Vec3();\r\n    private dragMoveSpeed = 0.01;\r\n    private dragRotateSpeed = 0.2;\r\n    private dragRotationQuat: Quat = new Quat();\r\n    private dragRotateEuler: Vec3 = new Vec3(); \r\n\r\n    onLoad() {\r\n        \r\n        //Manager.Instance().cameraController = Manager.Instance().cameraController.getComponent(CameraController);\r\n        //this.vertexManager = this.vertexManager.getComponent(VertexManager);\r\n        //this.vertexManager.createVertexAround(this.node); \r\n        \r\n\r\n\r\n        input.on(Input.EventType.MOUSE_DOWN, this.onMouseDown, this);\r\n        input.on(Input.EventType.MOUSE_UP, this.onMouseUp, this);\r\n        input.on(Input.EventType.MOUSE_MOVE, this.onMouseMove, this);\r\n        input.on(Input.EventType.MOUSE_WHEEL, this.onMouseWheel, this);\r\n    }\r\n\r\n    protected start(): void {\r\n                // reset the canvas\r\n        this.resetCanvas();\r\n    }\r\n\r\n    onMouseMove(event:EventMouse){\r\n        if(this.cameraMove){\r\n            /**\r\n             * Method 1. start -- camera rotate by itseif\r\n             */\r\n            \r\n\r\n            // const currentPosition = event.getLocation();\r\n            // const dx = event.getDeltaX();\r\n            // const dy = event.getDeltaY();\r\n            // let quat = Manager.Instance().cameraController.camera.node.rotation.clone();\r\n            // let quatX = Quat.fromEuler(new Quat(), dy * this.dragMoveSpeed, 0, 0);\r\n            // let quatY = Quat.fromEuler(new Quat(), 0, dx * this.dragMoveSpeed, 0);\r\n            // Quat.multiply(quat, quat, quatX);\r\n            // Quat.multiply(quat, quat, quatY);\r\n            // Manager.Instance().cameraController.camera.node.rotation = quat;\r\n            /**\r\n             * Method 1. end -- camera rotate by itself\r\n             */\r\n\r\n            /**\r\n             * Method 2. start -- camera move directly\r\n             */\r\n            const dx = event.getDeltaX();\r\n            const dy = event.getDeltaY();\r\n            let newPosition = new Vec3(\r\n                Manager.Instance().cameraController.camera.node.position.x - dx * this.dragMoveSpeed,\r\n                Manager.Instance().cameraController.camera.node.position.y - dy * this.dragMoveSpeed,\r\n                Manager.Instance().cameraController.camera.node.position.z\r\n            );\r\n\r\n            Manager.Instance().cameraController.camera.node.position = newPosition;\r\n\r\n\r\n\r\n            /**\r\n             * Method 2. end -- camera move directly\r\n             */\r\n\r\n            \r\n        }\r\n\r\n        else if(this.cameraRotateAroundVertex){\r\n            /**\r\n             * ---- start rorate nodes and its children --------\r\n             */\r\n            // let currentMousePosition = event.getLocation();\r\n            // let dx = (currentMousePosition.x - this.previousMousePosition.x) * this.dragRotateSpeed;\r\n            // let dy = (currentMousePosition.y - this.previousMousePosition.y) * this.dragRotateSpeed;\r\n            \r\n            // console.log(\"central node:\",Manager.Instance().vertexManager)\r\n            // let cameraQuaternion =  Manager.Instance().vertexManager.centralNode.rotation.clone();\r\n            // let rotateQuat = new Quat();\r\n            // Quat.fromEuler(rotateQuat, dy, dx, 0);\r\n            // Quat.multiply(rotateQuat, cameraQuaternion, rotateQuat);\r\n\r\n            // Manager.Instance().vertexManager.centralNode.setRotation(rotateQuat);\r\n            // //console.log(\"rotation focus node:\", this.centralVertex.getComponent(Vertex).getVertexID(),\" position:\",this.centralVertex.position)\r\n            \r\n            // this.previousMousePosition = currentMousePosition;\r\n            /**\r\n             * ---- end rorate nodes and its children --------\r\n             */\r\n\r\n            /**\r\n             * ---- start rorate camera ------------\r\n             */\r\n            let currentMousePosition = event.getLocation();\r\n            let dx = (currentMousePosition.x - this.previousMousePosition.x) * this.dragRotateSpeed;\r\n            let dy = (currentMousePosition.y - this.previousMousePosition.y) * this.dragRotateSpeed;\r\n            const angleX = (dx / 100) * 80;\r\n            const angleY = (dy / 100) * 80;\r\n            const cameraPos = Manager.Instance().cameraController.camera.node.worldPosition.clone();\r\n            const targetPos = Manager.Instance().vertexManager.currentCentralNode.worldPosition.clone();\r\n\r\n            // calculate the position after rotation\r\n            const rotatedPosX = Manager.Instance().cameraController.rotateOnVertex(cameraPos, targetPos, angleX, Vec3.UP);\r\n            const rotatedPosY = Manager.Instance().cameraController.rotateOnVertex(rotatedPosX, targetPos, angleY, Vec3.RIGHT);\r\n\r\n            // set the camera\r\n            Manager.Instance().cameraController.camera.node.worldPosition = rotatedPosY;\r\n            this.cameraRotateOffset = rotatedPosY;\r\n            Manager.Instance().cameraController.camera.node.lookAt(targetPos);\r\n\r\n            // uodate the mouse position\r\n            this.previousMousePosition = currentMousePosition;\r\n\r\n            /**\r\n             * ---- end rorate camera ------------\r\n             */\r\n            \r\n           \r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Event of pressing mouse down \r\n     * @param event \r\n     */\r\n    onMouseDown(event: EventMouse){\r\n        \r\n        /**\r\n         * mouse up by right key -- create vertex\r\n         */\r\n        if (event.getButton() === EventMouse.BUTTON_RIGHT) {\r\n\r\n            /**\r\n             * choose operation by click left button\r\n             */\r\n            // Manager.Instance().UIManager.dropDownBarLayout.node.setWorldPosition(event.getLocationX(), event.getLocationY(), 0);\r\n            // Manager.Instance().UIManager.dropDownBarLayout.node.active = true;\r\n            \r\n            this.chooseVertexOrEdgeAtMouse(event);\r\n            \r\n            //this.createVertexAtMouse(event);\r\n        } \r\n        /**\r\n         * press by middle key 存在bug：当按下中键拖动视角时，再双击鼠标选中某个节点为中心摄像机的角度会偏移\r\n         */\r\n        if(event.getButton() === EventMouse.BUTTON_MIDDLE){\r\n            \r\n            this.cameraMove = true;\r\n            this.previousMousePosition = event.getLocation();\r\n\r\n        }\r\n\r\n        /**\r\n         * press by left key\r\n         */\r\n        else if(event.getButton() === EventMouse.BUTTON_LEFT){\r\n            \r\n            this.chooseVertexOrEdgeAtMouse(event);\r\n            this.cameraRotateAroundVertex = true;\r\n            this.previousMousePositionVec3.set(event.getLocationX(), event.getLocationY(), 0);  \r\n            this.previousMousePosition = event.getLocation();\r\n            \r\n            \r\n        }\r\n    }\r\n\r\n    \r\n    /**\r\n     * Event of mouse up\r\n     * @param event \r\n     */\r\n    onMouseUp(event: EventMouse) {\r\n        // close the tagOrderList\r\n        Manager.Instance().UIManager.tagOrderChoiceBar.node.active = false;\r\n        /**\r\n         * mouse up by middle key\r\n         */\r\n        if (event.getButton() === EventMouse.BUTTON_MIDDLE) {\r\n           \r\n            this.cameraMove = false;\r\n            \r\n        }\r\n        /**\r\n         * mouse up by left key\r\n         */\r\n        else if(event.getButton() === EventMouse.BUTTON_LEFT){\r\n            if(Manager.Instance().UIManager.dropDownBarLayout.node.active = true) Manager.Instance().UIManager.dropDownBarLayout.node.active = false;\r\n            this.cameraRotateAroundVertex = false;\r\n            \r\n            \r\n           \r\n        }\r\n    }\r\n\r\n    /**\r\n     * mouse event of wheel, on camera zooming\r\n     * @param event \r\n     */\r\n    onMouseWheel(event: EventMouse) {\r\n        // get the y value of wheel \r\n        let scrollY = event.getScrollY();\r\n\r\n        // calculate and update new position of camera\r\n        let newCameraPos = new Vec3();        \r\n        math.Vec3.scaleAndAdd(newCameraPos, Manager.Instance().cameraController.camera.node.position, Manager.Instance().cameraController.camera.node.forward, this._zoomSpeed * scrollY);\r\n        Manager.Instance().cameraController.camera.node.position = newCameraPos;\r\n        \r\n    }\r\n\r\n\r\n\r\n    \r\n    onDestroy() {\r\n        input.off(Input.EventType.MOUSE_WHEEL, this.onMouseWheel, this);\r\n        input.off(Input.EventType.MOUSE_MOVE, this.onMouseMove, this);\r\n    }\r\n\r\n    /**\r\n     * do the collision detection by ray\r\n     * @param event \r\n     */\r\n    createVertexAtMouse(event: EventMouse) {\r\n        let ray = new geometry.Ray();\r\n        Manager.Instance().cameraController.camera.screenPointToRay(event.getLocationX(), event.getLocationY(), ray);\r\n        if (PhysicsSystem.instance.raycastClosest(ray)) {\r\n            \r\n            const result = PhysicsSystem.instance.raycastClosestResult;\r\n           \r\n            if (result.collider.node.getComponent(Vertex)) {\r\n                let childVertex = Manager.Instance().vertexManager.createNodeAround(result.collider.node);\r\n                Manager.Instance().edgeManager.createEdgeWithStartAndEnd(result.collider.node, childVertex);\r\n                \r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * when click and choose vertex\r\n     * @param event left click(0, 1, 2 times)\r\n     */\r\n    chooseVertexOrEdgeAtMouse(event:EventMouse){\r\n        \r\n        let ray = new geometry.Ray();\r\n        Manager.Instance().cameraController.camera.screenPointToRay(event.getLocationX(), event.getLocationY(), ray);\r\n        if (PhysicsSystem.instance.raycastClosest(ray)) {\r\n            \r\n            const result = PhysicsSystem.instance.raycastClosestResult;\r\n            /**\r\n             * if choose one vertex\r\n             */\r\n            if (result.collider.node.getComponent(Vertex)) {\r\n                Manager.Instance().edgeManager.returnFocusToNormalEdge();\r\n                \r\n                if(this.leftClickCount == 0){\r\n                    this.leftClickCount ++;\r\n                    this.centralVertex = result.collider.node;\r\n                    \r\n                \r\n                    // Manager.Instance().vertexManager.node.position = this.centralVertex.position;\r\n                    Manager.Instance().vertexManager.returnFocusToNormalVertex();\r\n                    Manager.Instance().vertexManager.chosenVertex = result.collider.node;\r\n                    Manager.Instance().vertexManager.chooseOneNormalVertexToFocus(result.collider.node); // change the chosen vertex\r\n                    \r\n                }  \r\n                /**\r\n                 * mouse click twice \r\n                 * camera focus on one vertex\r\n                 */\r\n                else if(this.leftClickCount == 1 && Manager.Instance().vertexManager.chosenVertex == result.collider.node) {\r\n                    \r\n                    Manager.Instance().cameraController.focusOn(result.collider.node);\r\n\r\n                    //Manager.Instance().vertexManager.currentCentralNode.getComponent(Vertex).showVertexDetails();\r\n\r\n                    this.leftClickCount = 0;\r\n                }\r\n                else if(this.leftClickCount == 1 && Manager.Instance().vertexManager.chosenVertex != result.collider.node){\r\n                    this.centralVertex = result.collider.node;\r\n                    Manager.Instance().vertexManager.returnFocusToNormalVertex();\r\n                    Manager.Instance().vertexManager.chosenVertex = result.collider.node;\r\n                    Manager.Instance().vertexManager.chooseOneNormalVertexToFocus(result.collider.node);\r\n                }  \r\n                else{\r\n                    this.leftClickCount = 0;\r\n                    Manager.Instance().vertexManager.returnFocusToNormalVertex();\r\n                }\r\n                result.collider.node.getComponent(Vertex).showVertexDetails();\r\n            }\r\n            else if(result.collider.node.getComponent(Edge)){\r\n                Manager.Instance().vertexManager.returnFocusToNormalVertex();\r\n                Manager.Instance().edgeManager.returnFocusToNormalEdge();\r\n                Manager.Instance().edgeManager.chosenEdgeNode = result.collider.node;\r\n                Manager.Instance().edgeManager.chooseNormalEdge(result.collider.node); \r\n                Manager.Instance().edgeManager.chosenEdgeNode.getComponent(Edge).showEdgeDetails();\r\n            }\r\n        }\r\n        \r\n        else{\r\n            this.leftClickCount = 0;\r\n            Manager.Instance().edgeManager.returnFocusToNormalEdge();\r\n            // Manager.Instance().vertexManager.returnFocusToNormalVertex();\r\n        } \r\n    }\r\n\r\n    /**\r\n     * clean the canvas\r\n     */\r\n    cleanCanvas(){\r\n        // clean vertices\r\n        Manager.Instance().vertexManager.destroyAllChildren();\r\n        Manager.Instance().vertexManager.returnFocusToNormalVertex();\r\n        // clean edges\r\n        Manager.Instance().edgeManager.destroyAllEdges();\r\n        Manager.Instance().edgeManager.returnFocusToNormalEdge();\r\n        //reset camera\r\n        Manager.Instance().cameraController.resetPosition();\r\n        // clean UI\r\n        Manager.Instance().UIManager.isNodeInfoEnable = false;\r\n        Manager.Instance().UIManager.nodeInfoBar.active = false;\r\n    }\r\n\r\n\r\n    /**\r\n     * clean the canvas and new a central node in Vec3(0,0,0)\r\n     */\r\n    resetCanvas(){\r\n        // reset vertices\r\n        Manager.Instance().vertexManager.destroyAllChildren();\r\n        Manager.Instance().vertexManager.initiateOriginalVertex();\r\n        Manager.Instance().vertexManager.returnFocusToNormalVertex();\r\n        // reset edges\r\n        Manager.Instance().edgeManager.destroyAllEdges();\r\n        Manager.Instance().edgeManager.returnFocusToNormalEdge();\r\n        // reset camera\r\n        Manager.Instance().cameraController.resetPosition();\r\n        // reset UI\r\n        Manager.Instance().UIManager.isNodeInfoEnable = false;\r\n        Manager.Instance().UIManager.nodeInfoBar.active = false;\r\n        \r\n        \r\n    }\r\n\r\n    \r\n}\r\n","import { _decorator, Component, Node } from 'cc';\nconst { ccclass, property } = _decorator;\n\n@ccclass('Constant')\nexport class Constant extends Component {\n\n}\n\nexport const PHY_GROUP = {\n    DEFAULT: 1 << 0,\n    MOUSE: 1 << 1,\n    EDGE: 1 << 2,\n    VERTEX: 1 << 3,\n};","import { _decorator, Component, Node } from 'cc';\r\nconst { ccclass, property } = _decorator;\r\n\r\ninterface IEventData{\r\n    func: Function;\r\n    target: any;\r\n}\r\n\r\ninterface IEvent{\r\n    [eventName: string]:IEventData[];\r\n}\r\n\r\n@ccclass('CustomEventListener')\r\nexport class CustomEventListener extends Component {\r\n    public static handle: IEvent = {};\r\n\r\n    // start listening event\r\n    public static on(eventName:string, cb:Function,target?:any){\r\n        if(!this.handle[eventName]){\r\n            this.handle[eventName] = [];\r\n        }\r\n\r\n        const data: IEventData = {func: cb, target};\r\n        this.handle[eventName].push(data);\r\n\r\n        \r\n    }\r\n\r\n    // cancel listening event\r\n    public static off(eventName:string, cb: Function, target?:any){\r\n        const list = this.handle[eventName];\r\n        if(!list || list.length <= 0){\r\n            return;\r\n        }\r\n        for(let i = 0; i < list.length; i++){\r\n            const event = list[i];\r\n            if(event.func === cb && (!target || target ===event.target)){\r\n                list.splice(i, 1);\r\n                break;\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    // dispatch the event\r\n    public static dispatchEvent (eventName: string, ...args:any){\r\n        const list = this.handle[eventName];\r\n        if(!list || list.length <= 0){\r\n            return;\r\n        }\r\n\r\n        for(let i = 0; i < list.length; i++){\r\n            const event = list[i];\r\n            event.func.apply(event.target, args);\r\n        }\r\n    }\r\n}\r\n\r\n","import { _decorator, Component, Node } from 'cc';\r\nconst { ccclass, property } = _decorator;\r\n\r\n@ccclass('Dictionary')\r\nexport class Dictionary extends Component {\r\n    public key:string = '';\r\n    public value : [number];\r\n}\r\n\r\n","import { _decorator, Component, Node, Vec3,math, HingeConstraint, CCString, CCInteger,MeshRenderer, Collider, PhysicsGroup } from 'cc';\r\nimport { Manager } from './Manager';\r\nimport { Vertex } from './Vertex';\r\nimport { PHY_GROUP } from './Constant';\r\n\r\n\r\nconst { ccclass, property } = _decorator;\r\n\r\n@ccclass('Edge')\r\nexport class Edge extends Component {\r\n\r\n    @property(Vertex)\r\n    public startVertex:Vertex;\r\n    @property(Vertex)\r\n    public endVertex:Vertex;\r\n\r\n    @property(CCString)\r\n    public edgeName:string = \"\";\r\n    @property(CCString)\r\n    public edgeID:string = \"\";\r\n    @property(CCString)\r\n    public srcID:string = \"\";\r\n    @property(CCString)\r\n    public dstID:string = \"\";\r\n    @property(Object)\r\n    public properties: Object = new Object();\r\n    @property(CCInteger)\r\n    public rank: number = 0;\r\n    @property(CCString)\r\n    public type: String = \"edge\";\r\n    @property(Boolean)\r\n    public isLayouted:boolean = false;\r\n\r\n    // @property(HingeConstraint)\r\n    // public startJoint = new HingeConstraint();\r\n    // @property(HingeConstraint)\r\n    // public endJoint = new HingeConstraint();\r\n\r\n    /**\r\n     * create Edge by the start vertex and end vertex\r\n     * @param startNode:Node of start\r\n     * @param endNode :Node of start\r\n     */\r\n    public createEdgeWithStartAndEnd(startNode: Node,endNode: Node){\r\n        this.startVertex = startNode.getComponent(Vertex);\r\n        this.endVertex = endNode.getComponent(Vertex);\r\n        let start = startNode.worldPosition, end = endNode.worldPosition;\r\n        // this.startPosition = start;\r\n        // this.endPosition = end;\r\n        const center = (start.clone()).add(end).multiplyScalar(0.5);\r\n        this.node.setWorldPosition(center);\r\n\r\n        // set distance\r\n        const length = Vec3.distance(start,end)/2;\r\n        this.node.setScale(0.002, length, 0.002 ); \r\n\r\n        const dir = Vec3.subtract(new Vec3(), end, start).normalize();\r\n        const right = new Vec3(0, 1, 0);\r\n        const quat = new math.Quat();\r\n        math.Quat.rotationTo(quat, right, dir);\r\n        this.node.setRotation(quat);\r\n        \r\n        // set ID\r\n        this.srcID = this.startVertex.getVertexID();\r\n        this.dstID = this.endVertex.getVertexID();\r\n        //this.edgeID = Manager.Instance().relationManager.setedgeID();\r\n\r\n                \r\n        //set joint\r\n\r\n        // this.startJoint = new HingeConstraint();\r\n        // this.startJoint.connectedBody = startVertex.getComponent(RigidBody);\r\n\r\n        // console.log(\"try to joint start!\", this.startJoint.connectedBody);\r\n        // this.startJoint.pivotA = start.clone().subtract(center);\r\n        // this.startJoint.axis = new Vec3(0, 1, 0);\r\n        // this.startJoint.pivotB = new Vec3(0, 0, 0);\r\n        // console.log(\"joint start!\");\r\n        // this.endJoint = new HingeConstraint()\r\n        // this.endJoint.connectedBody = endVertex.getComponent(RigidBody);\r\n        // // this.endJoint.pivotA = end.clone().subtract(center);\r\n        // // this.endJoint.pivotB = new Vec3(0, 0, 0);\r\n        // console.log(\"joint end!\")\r\n    }\r\n\r\n    /**\r\n     * change position with startNode and endNode\r\n     * @param startNode \r\n     * @param endNode \r\n     */\r\n    public resetPosition(startNode: Node,endNode: Node){\r\n        let start = startNode.worldPosition, end = endNode.worldPosition;\r\n        const center = (start.clone()).add(end).multiplyScalar(0.5);\r\n        this.node.setWorldPosition(center);\r\n\r\n        // set distance\r\n        const length = Vec3.distance(start,end)/2;\r\n        this.node.setScale(0.002, length, 0.002 ); \r\n\r\n        const dir = Vec3.subtract(new Vec3(), end, start).normalize();\r\n        const right = new Vec3(0, 1, 0);\r\n        const quat = new math.Quat();\r\n        math.Quat.rotationTo(quat, right, dir);\r\n        this.node.setRotation(quat);\r\n    }\r\n\r\n    /**\r\n     * In Edge class\r\n     * add edge info in individual vertex, veretex manager and edge manager\r\n     * must call after the edge basic info and vertex basic info be given \r\n     * better called after setAttribute()\r\n     */\r\n    public addAllThisVertexEdgeInfoOnEdge(){\r\n        if(Manager.Instance().vertexManager.vertexEdgeDic[this.srcID] == null) \r\n        {\r\n            Manager.Instance().vertexManager.vertexEdgeDic[this.srcID] = [];\r\n        }\r\n        if(Manager.Instance().vertexManager.vertexEdgeDic[this.dstID] == null) \r\n        {\r\n            Manager.Instance().vertexManager.vertexEdgeDic[this.dstID] = [];\r\n        }\r\n        //Manager.Instance().vertexManager.vertexEdgeDic[this.srcID].push(this.edgeID);\r\n        this.startVertex.addEdgeInfoOnVertex(this);\r\n        this.endVertex.addEdgeInfoOnVertex(this);\r\n\r\n        Manager.Instance().edgeManager.edgeVertexDic[this.edgeID] = [this.srcID, this.dstID];\r\n    }\r\n\r\n    /**\r\n     * get the edge ID\r\n     * @returns:String \r\n     */\r\n    public getEdgeID(){\r\n        return this.edgeID;\r\n    }\r\n\r\n    /**\r\n     * change the material of edge node\r\n     * material[1] is yellow --  the focused material\r\n     * material[2] is white -- the original material\r\n     * @param edgeNode \r\n     */\r\n    public changeEdgeMaterialToFocused(){\r\n        let focusMaterial = this.getComponent(MeshRenderer).getMaterial(1);\r\n        this.node.getComponent(MeshRenderer).setMaterial(focusMaterial,0);\r\n    }\r\n\r\n    /**\r\n     * return this edge node to original white material -- material[2]\r\n     */\r\n    public returnToInitialMaterial(){\r\n        let initialMaterial = this.getComponent(MeshRenderer).getMaterial(2);\r\n        this.getComponent(MeshRenderer).setMaterial(initialMaterial, 0);\r\n    }\r\n\r\n    /**\r\n     * set the attribute of Edge by json\r\n     * @param attribute \r\n     */\r\n    public setAttribute(attribute: any) {\r\n        for (let key in attribute) {\r\n            if (this.hasOwnProperty(key)) {\r\n                this[key] = attribute[key];\r\n            }\r\n        }\r\n        this.edgeID = this.srcID +\" \"+this.edgeName+\" \"+this.dstID;\r\n        //console.log(\"Edge ID:\"+this.edgeID)\r\n        Manager.Instance().relationManager.setEdgeID(this.edgeID);\r\n    }\r\n\r\n        /**\r\n     * present the details of edge\r\n     */\r\n    public showEdgeDetails(){\r\n        // console.log(\"Edge name:\"+this.edgeID);\r\n        \r\n        // console.log(\"src vectex ID:\"+this.srcID);\r\n        \r\n       \r\n        \r\n        Manager.Instance().UIManager.setRichInfo(\"Edge name:\"+this.edgeName);\r\n        Manager.Instance().UIManager.setRichInfo(\"Edge ID:\"+this.edgeID);\r\n        Manager.Instance().UIManager.addRichInfo(\"src vectex ID:\"+this.srcID);\r\n        Manager.Instance().UIManager.addRichInfo(\"dst vectex ID:\"+this.dstID);\r\n       \r\n        // for(let key in this.properties){\r\n        //     console.log(\"key:\",key);\r\n        //     console.log(key+\": \"+this.properties[key]);\r\n        //     Manager.Instance().UIManager.addRichInfo(key+\": \"+this.properties[key]);\r\n        // }\r\n        this.printNestedJSON(this.properties,\"properties\");\r\n        Manager.Instance().UIManager.addRichInfo(\"rank:\"+this.rank);\r\n\r\n    }\r\n\r\n    private printNestedJSON(obj, parentKey = '') {\r\n         for (let key in obj) {\r\n           let newKey = parentKey ? `${parentKey}.${key}` : key;\r\n           if (typeof obj[key] === 'object' && obj[key] !== null) {\r\n             this.printNestedJSON(obj[key], newKey);\r\n           } else {\r\n            Manager.Instance().UIManager.addRichInfo(key+\": \"+this.properties[key]);\r\n           }\r\n         }\r\n    }\r\n\r\n}\r\n","import { _decorator, Component, Node, Prefab, instantiate, Vec3 } from 'cc';\r\nimport { Edge } from './Edge';\r\nimport { Vertex } from './Vertex';\r\nimport { Manager } from './Manager';\r\n\r\n\r\nconst { ccclass, property } = _decorator;\r\n\r\n@ccclass('EdgeManager')\r\nexport class EdgeManager extends Component {\r\n\r\n    @property({ type: Prefab })\r\n    public edgePrefab: Prefab = null;\r\n\r\n    @property(Node)\r\n    public chosenEdgeNode:Node;\r\n\r\n    /**\r\n     * like{'0':[0,2]}\r\n     * means 0 is the id of one edge, and 0 is its startVertex id, 2 is its endVeretex id\r\n     */\r\n    public edgeVertexDic: { [key: string]: any } = {};\r\n\r\n    /**\r\n     *  create Edge\r\n     * @param startNode \r\n     * @param endNode \r\n     */\r\n    createEdgeWithStartAndEnd(startNode: Node, endNode: Node):Node {\r\n        const edgeNode = instantiate(this.edgePrefab);\r\n        //edgeNode.parent = startNode;\r\n        edgeNode.setParent(Manager.Instance().edgeManager.node);\r\n        let edge = edgeNode.getComponent(Edge);\r\n\r\n        edge.createEdgeWithStartAndEnd(startNode,endNode);\r\n\r\n\r\n        // console.log(\"vertex dic:\", Manager.Instance().vertexManager.vertexEdgeDic);\r\n        return edgeNode;\r\n       \r\n        \r\n    }\r\n\r\n\r\n    chooseNormalEdge(edgeNode:Node){\r\n        edgeNode.getComponent(Edge).changeEdgeMaterialToFocused();\r\n    }\r\n\r\n    public returnFocusToNormalEdge(){\r\n        \r\n        if(!this.chosenEdgeNode) return;\r\n        this.chosenEdgeNode.getComponent(Edge).returnToInitialMaterial();\r\n        this.chosenEdgeNode = null;\r\n        Manager.Instance().UIManager.cleanAndDisableInfoBar();\r\n        \r\n\r\n    }\r\n\r\n    public removeLayoutFlags(){\r\n        \r\n        for(let child of this.node.children){\r\n            //console.log(\"node name:\",child.name);\r\n            child.getComponent(Edge).isLayouted = false;\r\n\r\n        }\r\n    }\r\n\r\n    /**\r\n     * destroy all edge by remove the etities and node in list\r\n     */\r\n    destroyAllEdges() {\r\n        this.node.destroyAllChildren();\r\n        this.node.removeAllChildren();\r\n        \r\n    }\r\n\r\n\r\n}\r\n","import { _decorator, Component, Node } from 'cc';\nimport { Manager } from './Manager';\nconst { ccclass, property } = _decorator;\n\n@ccclass('Graphplayer')\nexport class Graphplayer extends Component {\n    protected start(): void {\n        \n        Manager.Instance().canvasManager.cleanCanvas();\n        Manager.Instance().JSONReader.getJSONResponse(\"http://127.0.0.1:8000/table-details\");\n        // this.startWithTableDetails(\"http://127.0.0.1:8000\");\n    }\n    /**\n     * change the url to get json \n     * @param url : like \"http://127.0.0.1:8080\"\n     */\n    public changeJSONResponseUrl(url:string){\n        Manager.Instance().UIManager.jsonResponseUrl = url;\n    }\n    \n    public startWithTableDetails(url:string){\n    //     const jsonString = localStorage.getItem('table-details');\n        //const jsonString = Manager.Instance().JSONReader.getCookie('table-details');\n        // const jsonString = sessionStorage.getItem('table-details');\n        const xhr = new XMLHttpRequest();\n        console.log(\"sucess on cocos!\")\n        xhr.onreadystatechange = function () {\n            console.log(\"xhr.readyState: \",xhr.readyState ,\"xhr.status:\",xhr.status)\n          if (xhr.readyState === 4 && xhr.status === 200) {\n            const jsonString = JSON.parse(xhr.responseText);\n            console.log(\"jsonString :\",jsonString )\n            Manager.Instance().JSONReader.transTabletoVertexAndEdge(jsonString);\n          }\n        };\n        xhr.open(\"GET\", url, true);\n        xhr.setRequestHeader(\"Content-Type\", \"application/json;charset=UTF-8\");\n        xhr.send();\n\n\n    }\n}\n\n","import { _decorator, Component, error, JsonAsset, Node,resources} from 'cc';\nconst { ccclass, property } = _decorator;\nimport { TableData } from './TableData';\nimport { Manager } from './Manager';\nimport { Vertex } from './Vertex';\nimport { Edge } from './Edge';\n\n\n@ccclass('JSONReader')\nexport class JSONReader extends Component {\n\n    @property({type: [TableData]})\n    public tableDataArray:Array<TableData>;\n\n\n\n    /**\n     * get JSON from file\n     * @param filename \n     */\n    public putJSONtoModel(filename: any){\n\n\n      /**\n       * load local JSON file in Response/...\n       */\n        let path = 'Response/' + filename;\n        this.loadJson(path, (tables) => {\n          this.transTabletoVertexAndEdge(tables);\n          \n          // console.log(\"set this.vertexIDBox args:\",Manager.Instance().relationManager.vertexIDBox);\n        });\n\n\n    }\n\n        // private loadJson(callback){\n      // resources.load('Response/sns', (err: any, res: JsonAsset) => {\n    private loadJson(path: string, callback: (tables: any) => void) {\n          resources.load(path, (err: any, res: JsonAsset) => {\n          if (err) {\n              error(err.message || err);\n              return;\n          }\n          // get data of JSON\n          let jsonData = res.json;\n          let tables = jsonData.data[0].data.tables;\n          callback(tables);\n          \n  \n  \n          });\n      }\n  \n\n    public getCookie(name:string) {\n        const value = \"; \" + document.cookie;\n        const parts = value.split(\"; \" + name + \"=\");\n        if (parts.length === 2) return decodeURIComponent(parts.pop().split(\";\").shift());\n    }\n    /**\n     * get json data  \n     * @param url: url of website to get json response\n     */\n    public getJSONResponse(url:string){\n \n      //console.log(\"1.url:\",url)\n      \n      fetch(url).then((response: Response) => {\n        //console.log(\"url:\",url)\n        console.log(response)\n        return response.json();\n         }).then((value) => {\n        \n        let tables = value.data[0].data.tables;\n        this.transTabletoVertexAndEdge(tables);\n    }).catch((error) => console.error('Fetch error:', error));\n\n    }\n\n\n    public transTabletoVertexAndEdge(tables:any){\n      for(let i = 0; i < tables.length; i++) {\n        let edges = tables[i]._edgesParsedList;\n        let vertices = tables[i]._verticesParsedList;\n        \n    \n        /**\n         * only for table has 1 edge with 2 vertices\n         */\n        let edge = edges[0], startVertex = vertices[0],endVertex = vertices[1];\n        let startNode = null, endNode = null, edgeNode= null;\n\n        let isStartVertexExists = Manager.Instance().relationManager.existVertex(startVertex.vid);\n        let isEndVertexExits = Manager.Instance().relationManager.existVertex(endVertex.vid);\n        let isEdgeExits = Manager.Instance().relationManager.existEdge(startVertex.vid+\" \"+edge.edgeName+\" \"+endVertex.vid);\n        // when edge doesn't exist\n       \n        if(!isEdgeExits){\n          // create vertices ofstart, end and edge\n          if(!isStartVertexExists && !isEndVertexExits){\n\n              startNode = Manager.Instance().vertexManager.createStartNode();\n              startNode.getComponent(Vertex).setAttribute(startVertex);\n              endNode = Manager.Instance().vertexManager.createNodeAround(startNode);\n              endNode.getComponent(Vertex).setAttribute(endVertex);\n              edgeNode = Manager.Instance().edgeManager.createEdgeWithStartAndEnd(startNode, endNode);\n              edgeNode.getComponent(Edge).setAttribute(edge);\n              edgeNode.getComponent(Edge).addAllThisVertexEdgeInfoOnEdge();\n              /** increase degree */\n              startNode.getComponent(Vertex).increaseVertexDegree();\n              endNode.getComponent(Vertex).increaseVertexDegree();\n              Manager.Instance().relationManager.increaseTagDegree(startNode.getComponent(Vertex));\n              Manager.Instance().relationManager.increaseTagDegree(endNode.getComponent(Vertex));\n          }\n\n          // start vertex exsited, create end vertex and edge\n          else if(isStartVertexExists && !isEndVertexExits){\n              \n              startNode = Manager.Instance().vertexManager.getVertexNodeByVID(startVertex.vid);\n              endNode = Manager.Instance().vertexManager.createNodeAround(startNode);\n              endNode.getComponent(Vertex).setAttribute(endVertex);\n              edgeNode = Manager.Instance().edgeManager.createEdgeWithStartAndEnd(startNode, endNode);\n              edgeNode.getComponent(Edge).setAttribute(edge);\n              edgeNode.getComponent(Edge).addAllThisVertexEdgeInfoOnEdge();\n              /** increase degree */\n              startNode.getComponent(Vertex).increaseVertexDegree();\n              endNode.getComponent(Vertex).increaseVertexDegree();\n              Manager.Instance().relationManager.increaseTagDegree(startNode.getComponent(Vertex));\n              Manager.Instance().relationManager.increaseTagDegree(endNode.getComponent(Vertex));\n\n          }\n          // end vertex exsited, create start vertex and edge\n          else if(!isStartVertexExists && isEndVertexExits){\n            \n            endNode = Manager.Instance().vertexManager.getVertexNodeByVID(endVertex.vid);\n            startNode = Manager.Instance().vertexManager.createNodeAround(endNode);\n            startNode.getComponent(Vertex).setAttribute(startVertex);\n            edgeNode = Manager.Instance().edgeManager.createEdgeWithStartAndEnd(startNode, endNode);\n            edgeNode.getComponent(Edge).setAttribute(edge);\n            edgeNode.getComponent(Edge).addAllThisVertexEdgeInfoOnEdge();\n            /** increase degree */\n            startNode.getComponent(Vertex).increaseVertexDegree();\n            endNode.getComponent(Vertex).increaseVertexDegree();\n            Manager.Instance().relationManager.increaseTagDegree(startNode.getComponent(Vertex));\n            Manager.Instance().relationManager.increaseTagDegree(endNode.getComponent(Vertex));\n\n          }\n          // both start and end vertex exsited, only create edge\n          else if(isStartVertexExists && isEndVertexExits){\n            \n            startNode = Manager.Instance().vertexManager.getVertexNodeByVID(startVertex.vid);\n            endNode = Manager.Instance().vertexManager.getVertexNodeByVID(endVertex.vid);\n            edgeNode = Manager.Instance().edgeManager.createEdgeWithStartAndEnd(startNode, endNode);\n            edgeNode.getComponent(Edge).setAttribute(edge);\n            edgeNode.getComponent(Edge).addAllThisVertexEdgeInfoOnEdge();\n            /** increase degree */\n            startNode.getComponent(Vertex).increaseVertexDegree();\n            endNode.getComponent(Vertex).increaseVertexDegree();\n            Manager.Instance().relationManager.increaseTagDegree(startNode.getComponent(Vertex));\n            Manager.Instance().relationManager.increaseTagDegree(endNode.getComponent(Vertex));\n\n            \n\n          }\n          // no such situation\n          /*\n          else if(isStartVertexExists && isEdgeExits){\n            \n            startNode = Manager.Instance().vertexManager.getVertexNodeByVID(startVertex.vid);\n            endNode = Manager.Instance().vertexManager.getVertexNodeByVID(endVertex.vid);\n            edgeNode = Manager.Instance().edgeManager.createEdgeWithStartAndEnd(startNode, endNode);\n            edgeNode.getComponent(Edge).setAttribute(edge);\n            edgeNode.getComponent(Edge).addAllThisVertexEdgeInfoOnEdge();\n            console.log(\"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\");\n\n          }*/\n          \n        }\n\n        /*\n        for(let j = 0; j < edges.length; j++) {\n            let edge = edges[j];\n            console.log(\"Edge: \"+ i +\" Edge SrcID: \" + edge.srcID +\"Edge DstID: \" + edge.dstID);\n            \n        }        \n        for(let j = 0; j < vertices.length; j++) {\n            let vertex = vertices[j];\n            console.log(\"Vertex ID: \" + vertex.vid);\n            \n        }\n        */\n\n\n    }\n    //console.log(\"relation vertex:\",Manager.Instance().relationManager.vertexIDBox);\n  }\n}\n\n","import { _decorator, Component, Node, Vec3, Quat, VERSION, instantiate, math} from 'cc';\nimport { Manager } from './Manager';\nimport { Vertex } from './Vertex';\nimport { Edge } from './Edge';\nconst { ccclass, property } = _decorator;\n\n@ccclass('LayoutManager')\nexport class LayoutManager extends Component {\n    private tagsNodeList = [] // restore the empty nodes of tags such like: player, team...\n\n    public centerToTag0Radius = 3; // radius between node and center\n\n    public tagsNodeRadius = 1.5; // radius between nodes of different tags, like tag 0 node and tag 1 nodes...\n\n    private nodesLayerRadiusInterval = Math.PI * 1/12;\n\n\n    /**\n     * re-classify nodes by tags\n     * the vertex with tag will be the child of corresponding tagNode\n     */\n    public classifyNodeByTag(){\n        let tagNodeCount = 0;\n        //this.tagsNodeList = [];\n        \n        /**\n         * set the tagNodeList(store Node)\n         */\n        try{\n            for(let tag of Manager.Instance().vertexManager.vertexTagSet){\n                if(!Manager.Instance().vertexManager.rootNode.getChildByName(tag))\n                {\n                    let newTagNode = new Node(tag);\n                    newTagNode.parent = Manager.Instance().vertexManager.rootNode;\n                    newTagNode.name = tag;\n                    this.tagsNodeList.push(newTagNode);\n                }\n            }\n\n          \n            while(Manager.Instance().vertexManager.rootNode.children.length > this.tagsNodeList.length ){\n                // let childVertex = Manager.Instance().vertexManager.rootNode.children[0];\n                let childVertex = Manager.Instance().vertexManager.rootNode.children[tagNodeCount];\n                if(childVertex.getComponent(Vertex) != null) {\n                    let vertexTag  = childVertex.getComponent(Vertex).tags[0];\n                    childVertex.setParent(Manager.Instance().vertexManager.rootNode.getChildByName(vertexTag));\n                    \n                }\n                else{\n                    tagNodeCount++;\n                }\n            \n            }\n            \n        }\n        catch(error){\n            console.log(error)\n        }\n\n        this.nodesLayerRadiusInterval = Math.PI / 2 / this.tagsNodeList.length;\n\n\n    }\n\n    /**\n     * change the orders of tags\n     * @param tagsName: string slist if tags\n     */\n    public adjustOrderOfTags(tagsName:string[]){\n        this.tagsNodeList = []; \n        console.log(\"order by,\", tagsName);\n        for(let tagName of tagsName){\n            this.tagsNodeList.push(Manager.Instance().vertexManager.rootNode.getChildByName(tagName));\n        } \n       \n    }\n\n    /**\n     * one method to re-Layout by tags\n     */\n    public reLayoutByTags(){\n\n        /**\n         * reLayout tag 0 node, with rootNode as center\n         */\n        let center = Manager.Instance().vertexManager.rootNode.worldPosition;\n        let nodes = this.tagsNodeList[0].children; // list of nodes around center\n        let angleStep = 2 * Math.PI / nodes.length; // set the step of angle\n        for (let i = 0; i < nodes.length; i++) {\n            let angle = i * angleStep; // set nodes angles\n        \n            // calculate the position \n            let x = center.x + this.centerToTag0Radius * Math.cos(angle);\n            let y = center.y;\n            let z = center.z + this.centerToTag0Radius * Math.sin(angle);\n        \n            nodes[i].setWorldPosition(x, y, z); // set postion of node\n            nodes[i].getComponent(Vertex).isLayouted = true; // if do not have this sentencec, nodes will layout like tree\n        }\n\n        /**\n         * tag 1--n: rotate with tag 0 align on another plant\n         * realign edge as well\n         */\n    \n        for(let tag0Node of nodes){\n\n\n                this.updateEndVertexAndEdge(tag0Node);\n\n    }\n\n    }\n\n    // private traverseNodeAndUpdate(rootNode:Node){\n    //     for(let child of rootNode.children){\n    //         this.updateEndVertexAndEdge(child);\n\n    //     }\n    // }\n\n    /**\n     * update the endvertex and edge of one start vertex\n     * @param startVertex: the center of the sub-layer of endvertex and edge\n     */\n    private updateEndVertexAndEdge(startVertex:Node){\n\n       \n       // if(startVertex.getComponent(Vertex).edgesSetOfVertex.length <= 1) return;\n        let edgeNum = startVertex.getComponent(Vertex).edgesSetOfVertex.length;\n        \n        \n        \n        // if(edgeNum < 2) return;\n\n        let areAllEdgesLayouted = true;\n        for(let edge of startVertex.getComponent(Vertex).edgesSetOfVertex){\n            \n            if(edge.isLayouted == false) areAllEdgesLayouted = false;\n            // else{\n            //     console.log(\"unlayouted edge:\",edge.edgeID)\n            // }\n        }\n        if(areAllEdgesLayouted) return;\n        let center = startVertex.worldPosition;\n        \n        // calcualte the normal vector of plant of tag0, rootNode and up-vector\n        let normal = new Vec3();\n        Vec3.cross(normal, Vec3.subtract(new Vec3(), center, Vec3.ZERO), Vec3.UP);\n        Vec3.normalize(normal, normal);\n\n        /**\n         * calculate initial vector of plant of tag0, rootNode and up-vector\n         */\n        let initialVector = new Vec3();\n        // Vec3.cross(initialVector, normal, Vec3.subtract(new Vec3(), center, Vec3.ZERO));\n        initialVector = Vec3.subtract(new Vec3(), center, Vec3.ZERO);\n        Vec3.normalize(initialVector, initialVector);\n        //let selfAngleStep = 2 * Math.PI / edgeNum; // rotate on 2 PI\n        let selfAngleStep =  Math.PI / edgeNum;// rotate on PI\n        let initialAngle =  Math.PI * 3/2;\n        let selfAngle = 0; // initial angle --- PI/6 and it orient outside\n        let derivedNodeCount = 0;\n       \n        for(let i = 0; i < startVertex.getComponent(Vertex).edgesSetOfVertex.length; i++){\n            let edge = startVertex.getComponent(Vertex).edgesSetOfVertex[i];\n            if(edge.isLayouted) continue;\n            let endVertex = edge.endVertex;\n            \n            /**\n             * different tag with different normal and initialVector\n             */\n            let angleBiasBetweenTags = this.getTagIndex(endVertex.getComponent(Vertex).tags[0]) * this.nodesLayerRadiusInterval; // set the bias of each tag, ranked by first index\n            let quat = new Quat();\n            let tmp_normal = new Vec3();\n           \n            let tmp_initialVector = new Vec3();\n            Quat.fromAxisAngle(quat, normal, angleBiasBetweenTags);\n            // trans normal\n            Vec3.transformQuat(tmp_initialVector, initialVector, quat);\n            Quat.fromAxisAngle(quat, initialVector, angleBiasBetweenTags);\n            // trans normal\n            Vec3.transformQuat(tmp_normal, normal, quat);\n\n            if(edge.startVertex.vid != startVertex.getComponent(Vertex).vid){\n                endVertex = edge.startVertex;\n            }\n            if(!endVertex.isLayouted){\n\n                let position = new Vec3();\n                let vectorWithRadius = new Vec3();\n                selfAngle = initialAngle + selfAngleStep * this.getElementIndex(edge, startVertex.getComponent(Vertex).edgesSetOfVertex);\n                Vec3.multiplyScalar(vectorWithRadius,tmp_initialVector.clone(), this.tagsNodeRadius);\n                //console.log(\"vectorWithRadius:\",vectorWithRadius,\"tmp_initialVector.clone():\",tmp_initialVector.clone(),\"this.tagsNodeRadius:\",this.tagsNodeRadius)\n                let quaternion = new Quat();\n                Quat.fromAxisAngle(quaternion, tmp_normal,selfAngle);\n            \n\n\n                Vec3.transformQuat(vectorWithRadius, vectorWithRadius, quaternion);\n            \n                Vec3.add(position, center.clone(), vectorWithRadius);\n                endVertex.node.setWorldPosition(position);\n                \n                endVertex.isLayouted = true;\n                derivedNodeCount++;\n                \n                // selfAngle += initialAngle + derivedNodeCount * selfAngleStep; // update angle\n                //console.log(\"start:\",startVertex.getComponent(Vertex).vid, \" :\",endVertex.vid,\" degree:\",selfAngle/Math.PI,\" adding:\",selfAngleStep/Math.PI)\n                \n                \n            }\n            /** \n             * reLayout the edge\n             */\n            //console.log(startVertex.getComponent(Vertex).vid+\" count:\",derivedNodeCount, \"len:\",startVertex.getComponent(Vertex).edgesSetOfVertex.length)\n            edge.resetPosition(startVertex, endVertex.node);\n            edge.isLayouted = true;\n            this.updateEndVertexAndEdge(endVertex.node);\n        }\n\n       \n        //console.log(\"edge after:\",Manager.Instance().edgeManager.node.children.length)\n            \n    }\n\n    /**\n     * each child of one tag with same material\n     */\n    public materialReallocated(){\n        let tagIndex = 2;\n\n        for(let tagNode of this.tagsNodeList){\n            for(let childVertex of tagNode.children){\n                childVertex.getComponent(Vertex).setMaterialCode(tagIndex);//change the material code\n                childVertex.getComponent(Vertex).changeMaterial(tagIndex);\n            }\n            tagIndex++;\n        }\n    }\n\n    /**\n     * getTagIndex in list of tags\n     * @param tag \n     * @returns \n     */\n    private getTagIndex(tag:string) {\n        for(let index = 0; index < this.tagsNodeList.length; index++){\n            if(this.tagsNodeList[index].name == tag) return index;\n        }\n        return -1;\n    }\n\n    /**\n     * get element index in lists\n     * @param element \n     * @param list \n     * @returns \n     */\n    private getElementIndex(element:any, list:any[]){\n        for(let index = 0; index < list.length; index++){\n            if(list[index] == element) return index;\n        }\n        return -1;\n    }\n\n    /**\n     *  transform taglist(Node) to taglist(string)\n     * @returns \n     */\n    public getTags():string[]{\n        let tagList = [];\n        for(let tagNode of this.tagsNodeList){\n            tagList.push(tagNode.name);\n        }\n        return tagList; \n    }\n}","import { _decorator, Component,physics } from 'cc';\r\nimport { CameraController } from './CameraController';\r\nimport { VertexManager } from './VertexManager';\r\nimport { CanvasManager } from './CanvasManager';\r\nimport { EdgeManager } from './EdgeManager';\r\nimport { RelationManager } from './RelationManager';\r\nimport { UIManager } from './UIManager';\r\nimport { JSONReader } from './JSONReader';\r\nimport { LayoutManager } from './LayoutManager';\r\nconst { ccclass, property } = _decorator;\r\n\r\n@ccclass('Manager')\r\nexport class Manager extends Component {\r\n \r\n    \r\n    @property(CameraController)\r\n    public cameraController: CameraController;\r\n\r\n    @property(VertexManager)\r\n    public vertexManager: VertexManager;\r\n\r\n    @property(CanvasManager)\r\n    public canvasManager: CanvasManager;\r\n\r\n    @property(EdgeManager)\r\n    public edgeManager: EdgeManager;\r\n\r\n    @property(RelationManager)\r\n    public relationManager: RelationManager;\r\n\r\n    @property(UIManager)\r\n    public UIManager: UIManager;\r\n\r\n    @property(JSONReader)\r\n    public JSONReader:JSONReader;\r\n\r\n    @property(LayoutManager)\r\n    public layoutManager:LayoutManager;\r\n\r\n    static instance:Manager = new Manager();\r\n\r\n    protected onLoad(): void {\r\n        physics.PhysicsSystem.instance.enable = true;\r\n        Manager.instance.cameraController = this.node.getChildByName('CameraController').getComponent(CameraController);\r\n        Manager.instance.vertexManager = this.node.getChildByName('Canvas').getChildByName('VertexManager').getComponent(VertexManager);\r\n        Manager.instance.canvasManager = this.node.getChildByName('CanvasManager').getComponent(CanvasManager);\r\n        Manager.instance.edgeManager = this.node.getChildByName('EdgeManager').getComponent(EdgeManager);\r\n        Manager.instance.relationManager = this.node.getChildByName('RelationManager').getComponent(RelationManager);\r\n        Manager.instance.UIManager = this.node.getChildByName('Canvas').getChildByName('UIManager').getComponent(UIManager);\r\n        Manager.instance.JSONReader = this.node.getChildByName('JSONReader').getComponent(JSONReader);\r\n        Manager.instance.layoutManager = this.node.getChildByName('LayoutManager').getComponent(LayoutManager);\r\n        Manager.Instance();\r\n\r\n        console.log(\"find: \", Manager.instance.layoutManager);\r\n    }\r\n    \r\n    \r\n\r\n    \r\n    static Instance(){\r\n        if(!Manager.instance){\r\n            Manager.instance = new Manager();\r\n\r\n        }\r\n        return Manager.instance;\r\n    }\r\n\r\n}\r\n\r\n","import { _decorator, CCInteger, CCString, Component, Node } from 'cc';\r\nconst { ccclass, property } = _decorator;\r\nimport { Vertex } from './Vertex';\r\n\r\n@ccclass('RelationManager')\r\nexport class RelationManager extends Component {\r\n\r\n    @property({ type:Set })\r\n    vertexIDBox:Set<string> = new Set<string>();\r\n\r\n    @property({ type:Set})\r\n    edgeIDBox:Set<string> = new Set<string>();\r\n\r\n\r\n    @property(CCInteger)\r\n    vertexCount:number = 0;\r\n\r\n    @property(CCInteger)\r\n    edgeCount:number = 0;\r\n\r\n    \r\n    public tagDegreeDic: {[key:number]:any[]} = {}; \r\n\r\n    public tagDegreeDicLength = 0;\r\n\r\n    protected onLoad(): void {\r\n        this.vertexIDBox = new Set<string>();\r\n        this.edgeIDBox = new Set<string>();\r\n\r\n    }\r\n    /**\r\n     * set the vertexID self-defined\r\n     * @param s \r\n     */\r\n    public setVertexID(...args: string[]){ \r\n        \r\n        if(args.length == 1){\r\n            let [s] = args;\r\n            this.vertexIDBox.add(s);\r\n            this.vertexCount++;\r\n            return s;\r\n        }\r\n        else{\r\n            this.vertexCount++;\r\n            this.vertexIDBox.add( \"\" + this.vertexCount);\r\n            return \"\" + this.vertexCount;\r\n        }\r\n        \r\n        \r\n        // return this.vertexIDBox;\r\n        \r\n    }\r\n\r\n    /**\r\n     * pop the last element from Box\r\n     */\r\n    public removeVertex(vid: string){\r\n\r\n        if(this.vertexIDBox.has(vid)){\r\n            this.vertexIDBox.delete(vid);\r\n            this.vertexCount--;\r\n        }\r\n\r\n    }\r\n\r\n    public removeEdge(edgeID){\r\n        if(this.edgeIDBox.has(edgeID)){\r\n            this.edgeIDBox.delete(edgeID);\r\n            this.edgeCount--;\r\n        }\r\n\r\n    }\r\n\r\n\r\n    public setEdgeID(...args:string[]){\r\n        if(args.length == 1){\r\n            let [s] = args;\r\n            this.edgeIDBox.add(s);\r\n            this.edgeCount++;\r\n            return s;\r\n        }\r\n        else{\r\n            return \"\" + this.edgeCount;\r\n        }\r\n    }\r\n\r\n    public resetVertexAndEdgeBox(){\r\n        // console.log(this.vertexIDBox)\r\n        this.vertexIDBox.clear();\r\n        // this.vertexIDBox = new Set<string>();\r\n        this.edgeIDBox.clear();\r\n        this.vertexCount = 0;\r\n        this.edgeCount = 0;\r\n    }\r\n\r\n    public existVertex(vertexID:String):boolean{\r\n        for(let entry of this.vertexIDBox){\r\n            if(vertexID == entry) return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public existEdge(edgeID:String):boolean{\r\n        for(let entry of this.edgeIDBox){\r\n            if(edgeID == entry) return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // public increaseVertexDegree(vertex: Vertex){\r\n    //     let vid = vertex.vid;\r\n    //     this.vertexDegreeDic[vid]++;\r\n    //     //console.log(\"vertex:\",vid,\" number:\",this.vertexDegreeDic[vid])\r\n    // }\r\n\r\n\r\n    /**\r\n     * increase the degree of tag which the vertex belongs to\r\n     * @param vertex \r\n     */\r\n    public increaseTagDegree(vertex: Vertex){\r\n        if(!(vertex.tags[0] in this.tagDegreeDic)){\r\n            this.tagDegreeDic[vertex.tags[0]] = \"\";\r\n            this.tagDegreeDicLength++;\r\n        }\r\n        this.tagDegreeDic[vertex.tags[0]]++;\r\n    }\r\n}\r\n\r\n","import { _decorator, Component, Node } from 'cc';\nconst { ccclass, property } = _decorator;\nimport { Edge } from './Edge';\nimport { Vertex } from './Vertex';\n\n/**\n * data structure contain edges, vertices and thier properties\n */\n@ccclass('TableData')\nexport class TableData extends Component {\n    edges: Array<Edge>;\n    vertices: Array<Vertex>;\n\n    constructor(data: any) {\n        super();\n        this.edges = data._edgesParsedList.map((edgeData: any) => new Edge(edgeData));\n        this.vertices = data._verticesParsedList.map((vertexData: any) => new Vertex(vertexData));\n    }\n}\n\n","import { _decorator, Component, Node,EventHandler,Button, RichText, Layout, EventMouse,resources, Prefab, instantiate, Label, UITransform, EditBox } from 'cc';\r\nconst { ccclass, property } = _decorator;\r\nimport { Manager } from './Manager';\r\nimport { Vertex } from './Vertex';\r\n\r\n@ccclass('UIManager')\r\nexport class UIManager extends Component {\r\n\r\n    clickEventHandler = new EventHandler();\r\n\r\n    @property(Button)\r\n    private refreshBtn:Button;\r\n\r\n    @property(Button)\r\n    private createCanvasFromJSONButton:Button;\r\n\r\n    \r\n    @property(EditBox)\r\n    public createCanvasFromJSONEditBox:EditBox\r\n\r\n    @property(Node)\r\n    public nodeInfoBar:Node;\r\n\r\n    @property(RichText)\r\n    private nodeInfoText:RichText;\r\n\r\n    @property(Button)\r\n    private createVertexBtn:Button;\r\n    \r\n    @property(Button)\r\n    private createEdgeBtn:Button;\r\n\r\n    @property(Button)\r\n    private deleteVertexBtn:Button;\r\n\r\n    @property(Button)\r\n    private layoutBtn:Button;\r\n\r\n    @property(Layout)\r\n    public dropDownBarLayout:Layout;\r\n\r\n    @property(Layout)\r\n    public tagOrderChoiceBar:Layout;\r\n\r\n    @property(Prefab)\r\n    private tagOrderChoiceBtnPrefab:Prefab \r\n\r\n    @property({type: [Node]})\r\n    public tagOrderChoiceBtnList:Array<Node>;\r\n\r\n    public jsonResponseUrl = \"http://127.0.0.1:8080\";\r\n\r\n    private vertexIDLabelManager: Node;\r\n\r\n    private vertexIDLabelPrefab: Prefab;\r\n\r\n\r\n\r\n\r\n    /**\r\n     * attributes of tag Order bar and its choices buttons\r\n     */\r\n    private BtnWidth = 30;\r\n    private BtnLength = 170;\r\n    private timer = 0;\r\n    private isEnteredTagOrderChoiceBar = false;\r\n    \r\n    /**\r\n     * attributes of rich info about vertices and edges\r\n     */\r\n    public isNodeInfoEnable = false;\r\n    private nodeInfoPrefix = \"<color=#ffffff>\";\r\n    private nodeInfoSuffix = \"\\n</f>\";\r\n\r\n\r\n    public RefreshCanvas(event:Event){\r\n        \r\n        Manager.Instance().canvasManager.resetCanvas();\r\n        //Manager.Instance().JSONReader.putJSONtoModel(\"\");\r\n\r\n\r\n        \r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param event \r\n     * @param method:\"local\" or \"web\" \r\n     */\r\n    public createCanvasFromJSONFile(event:Event, method: string){\r\n        Manager.Instance().canvasManager.cleanCanvas();\r\n        \r\n        if(method == \"local\"){\r\n            const jsonFilename = this.createCanvasFromJSONEditBox.string;\r\n            Manager.Instance().JSONReader.putJSONtoModel(jsonFilename);\r\n        }\r\n        else if(method == \"web\"){\r\n        \r\n            Manager.Instance().JSONReader.getJSONResponse(this.jsonResponseUrl);\r\n       }\r\n    }\r\n\r\n    \r\n\r\n    public createVertex(event:Event){\r\n        // if the node is vertex\r\n       \r\n        \r\n        if(Manager.Instance().vertexManager.chosenVertex != null && Manager.Instance().edgeManager.chosenEdgeNode == null){\r\n            \r\n            let childVertex = Manager.Instance().vertexManager.createNodeAround(Manager.Instance().vertexManager.chosenVertex);\r\n            Manager.Instance().edgeManager.createEdgeWithStartAndEnd(Manager.Instance().vertexManager.chosenVertex, childVertex);\r\n        }\r\n        else if(Manager.Instance().vertexManager.chosenVertex == null && Manager.Instance().edgeManager.chosenEdgeNode != null){\r\n            \r\n            /**\r\n             * To-do create on edge\r\n             */\r\n\r\n        }\r\n        this.dropDownBarLayout.node.active = false;\r\n    }\r\n\r\n    public changeLayout(event:Event, finalTagOrder: string){\r\n        let finalTagOrderList = finalTagOrder.split(\",\");\r\n        //console.log(\"finalTagOrder:\",finalTagOrder+\"finalTagOrderList:\",finalTagOrderList)\r\n        this.tagOrderChoiceBar.node.active = false;\r\n        this.dropDownBarLayout.node.active = false;\r\n        \r\n        Manager.Instance().vertexManager.removeLayoutFlags();\r\n        \r\n        Manager.Instance().edgeManager.removeLayoutFlags();\r\n        \r\n        Manager.Instance().layoutManager.classifyNodeByTag();\r\n        Manager.Instance().layoutManager.adjustOrderOfTags(finalTagOrderList);\r\n        // Manager.Instance().layoutManager.adjustOrderOfTags([\"team\",\"player\"]);\r\n        Manager.Instance().layoutManager.materialReallocated();\r\n        Manager.Instance().layoutManager.reLayoutByTags();\r\n    }\r\n\r\n\r\n    protected onLoad(): void {\r\n            // initiate infomation bar\r\n            this.nodeInfoBar = this.node.getChildByName('InfoBar');\r\n            this.nodeInfoText = this.nodeInfoBar.getChildByName('NodeInfoText').getComponent(RichText);\r\n            // input.on(Input.EventType.MOUSE_UP, this.onMouseUp, this); // set the progation prevented\r\n            // input.on(Input.EventType.MOUSE_DOWN, this.onMouseDown, this);\r\n            // this.tagOrderChoiceBtnList = new Array<Node>();\r\n                    // 使用cc.resources.load来加载预制体\r\n        resources.load(\"Prefab/VertexIDLabel\" , Prefab, (err, prefab) => {\r\n            if (err) {\r\n                console.error(\"Failed to load prefab:\", err);\r\n                return;\r\n            }\r\n            else{\r\n                this.vertexIDLabelPrefab = prefab;\r\n            }\r\n        });\r\n    }\r\n\r\n    start () {\r\n        \r\n       \r\n        // initiate refresh button\r\n        const refreshClickEventHandler = new EventHandler();\r\n        this.refreshBtn = this.node.getChildByName('RefreshBtn').getComponent(Button);\r\n        refreshClickEventHandler.target = this.node; // node name\r\n        refreshClickEventHandler.component = 'UIManager';// script name\r\n        refreshClickEventHandler.handler = 'RefreshCanvas'; // method name\r\n        // const button = this.node.getComponent(Button);\r\n        this.refreshBtn.clickEvents.push(refreshClickEventHandler);\r\n\r\n        // initiate the JSON button\r\n        const createCanvasFromJSONFileEventHandler =  new EventHandler();\r\n        this.createCanvasFromJSONButton = this.node.getChildByName('CreateByJSONBtn').getComponent(Button);\r\n        this.createCanvasFromJSONEditBox = this.createCanvasFromJSONButton.node.getChildByName(\"EditBox\").getComponent(EditBox);\r\n        createCanvasFromJSONFileEventHandler.target = this.node;\r\n        createCanvasFromJSONFileEventHandler.component = 'UIManager';\r\n        createCanvasFromJSONFileEventHandler.customEventData = 'web';\r\n        createCanvasFromJSONFileEventHandler.handler = 'createCanvasFromJSONFile';\r\n        this.createCanvasFromJSONButton.clickEvents.push(createCanvasFromJSONFileEventHandler);\r\n        \r\n\r\n        /**\r\n         * initial the drop-down bar\r\n         */\r\n        this.dropDownBarLayout =  this.node.getChildByName(\"DropDownBar\").getComponent(Layout);\r\n        this.dropDownBarLayout.node.active = false;\r\n        \r\n\r\n        \r\n        // initial Layout Btn\r\n\r\n        const layoutEventHandler = new EventHandler();\r\n        // this.layoutBtn = this.dropDownBarLayout.node.getChildByName(\"LayoutBtn\").getComponent(Button);\r\n        this.layoutBtn = this.node.getChildByName(\"LayoutGreyBtn\").getComponent(Button);\r\n        // layoutEventHandler.target = this.node;\r\n        // layoutEventHandler.component = \"UIManager\";\r\n        // layoutEventHandler.handler = \"changeLayout\";\r\n        //this.layoutBtn.clickEvents.push(layoutEventHandler);\r\n        \r\n        this.tagOrderChoiceBar = this.layoutBtn.node.getChildByName(\"TagOrderChoiceBar\").getComponent(Layout);\r\n        \r\n        this.tagOrderChoiceBar.node.active = false;\r\n        /**\r\n         * listen on layout btn\r\n         */\r\n\r\n\r\n        this.layoutBtn.node.on(Node.EventType.MOUSE_ENTER, this.chooseLayoutBtn.bind(this, layoutEventHandler),this);\r\n        \r\n        this.layoutBtn.node.on(Node.EventType.MOUSE_LEAVE, this.onLayoutBtnMouseLeave,this);\r\n  \r\n        //this.tagOrderChoiceBar.node.on(Node.EventType.MOUSE_ENTER, this.onMouseEnterTagOrderChoiceBar, this);\r\n        this.tagOrderChoiceBar.node.on(Node.EventType.MOUSE_MOVE, this.onMouseEnterTagOrderChoiceBar, this); // listen on mouse enter in tagOrderChoiceBar \r\n        // this.tagOrderChoiceBar.node.on(Node.EventType.MOUSE_LEAVE,(event:EventMouse) => {\r\n        //     this.isEnteredTagOrderChoiceBar = false;\r\n        // }, this);\r\n\r\n        /** close by click mouse on CanvasMAnager.onMouseUp() */\r\n        this.tagOrderChoiceBar.node.on(Node.EventType.MOUSE_LEAVE,this.onMouseLeaveTagOrderChoiceBar, this);\r\n\r\n        /**\r\n         * initial layout choice bar\r\n         */\r\n\r\n        \r\n\r\n        // initial createVertexBtn \r\n        const createVertexEventHandler = new EventHandler();\r\n        this.createVertexBtn = this.dropDownBarLayout.node.getChildByName(\"CreateVertexBtn\").getComponent(Button);\r\n        createVertexEventHandler.target = this.node;\r\n        createVertexEventHandler.component = \"UIManager\";\r\n        createVertexEventHandler.handler = \"createVertex\";\r\n        this.createVertexBtn.clickEvents.push(createVertexEventHandler);\r\n\r\n        // initial deleteVeretxBtn\r\n        const deleteVertexEventHandler = new EventHandler();\r\n        this.deleteVertexBtn = this.dropDownBarLayout.node.getChildByName(\"DeleteVertexBtn\").getComponent(Button);\r\n        deleteVertexEventHandler.target = this.node;\r\n        deleteVertexEventHandler.component = \"UIManager\";\r\n        deleteVertexEventHandler.handler = \"createVertex\";\r\n       \r\n\r\n        this.deleteVertexBtn.clickEvents.push(createVertexEventHandler);\r\n\r\n    }\r\n\r\n\r\n    private onMouseEnterTagOrderChoiceBar(event: EventMouse){\r\n        \r\n        this.isEnteredTagOrderChoiceBar = true;\r\n       \r\n    }\r\n\r\n    private onMouseLeaveTagOrderChoiceBar(event:EventMouse){\r\n       \r\n        this.isEnteredTagOrderChoiceBar = false;\r\n        \r\n        this.tagOrderChoiceBar.node.active = false;\r\n    }\r\n    /**\r\n     * set the info\r\n     * @param info: info of vertex and edge\r\n     */\r\n    public setRichInfo(info:string){\r\n        this.nodeInfoBar.active = true;\r\n        if(!this.isNodeInfoEnable) {\r\n            this.isNodeInfoEnable = true;\r\n            this.nodeInfoBar.active = true;\r\n        }\r\n\r\n        this.nodeInfoText.string = this.nodeInfoPrefix+info+this.nodeInfoSuffix;\r\n    }\r\n\r\n    /**\r\n     * add info\r\n     * @param info \r\n     */\r\n    public addRichInfo(info:string){\r\n\r\n        this.nodeInfoText.string += this.nodeInfoPrefix+info+this.nodeInfoSuffix;\r\n    }\r\n\r\n    /**\r\n     * clean info in block\r\n     */\r\n    public cleanRichInfo(){\r\n        this.nodeInfoText.string = \"\";\r\n        \r\n    }\r\n\r\n    public cleanAndDisableInfoBar(){\r\n        this.nodeInfoText.string = \"\";\r\n        this.nodeInfoBar.active = false;\r\n    }\r\n\r\n    /**\r\n     * show the order of tags\r\n     */\r\n    private chooseLayoutBtn(){\r\n        \r\n        try{\r\n            this.cleanTagOrderChoices();\r\n            \r\n            /** \r\n             * read the possible layout order \r\n             */\r\n            let tagList = Array.from(Manager.Instance().vertexManager.vertexTagSet);\r\n            if(tagList.length == 0) return;\r\n            /**\r\n             * order of\r\n             */\r\n            // let tagOrderList = [];\r\n            // this.generatePermutations(tagList,[],tagOrderList);\r\n            let tagOrderList = Object.keys(Manager.Instance().relationManager.tagDegreeDic);\r\n            let tagOrderNum = tagOrderList.length;\r\n            // let this.tagOrderChoiceBtnList = []\r\n            this.tagOrderChoiceBar.getComponent(UITransform).setContentSize(this.BtnLength, (tagOrderNum) * this.BtnWidth);\r\n            this.tagOrderChoiceBtnList = new Array<Node>(tagOrderNum);\r\n            \r\n            \r\n            /**\r\n             * show the layout order choices \r\n            */\r\n            \r\n                for(let i = 0; i < tagOrderList.length; i++){\r\n                    const tagOrderBtn = instantiate(this.tagOrderChoiceBtnPrefab);\r\n                \r\n                    tagOrderBtn.setParent(this.tagOrderChoiceBar.node);\r\n                    tagOrderBtn.setPosition(0, i * this.BtnWidth, 0);\r\n                    tagOrderBtn.getChildByName('Label').getComponent(Label).string = tagOrderList[i]; // set the string of tag order button\r\n                    \r\n                    const tagOrderChoiceHandler = new EventHandler();\r\n                    tagOrderChoiceHandler.target = this.node;\r\n                    tagOrderChoiceHandler.component = \"UIManager\";\r\n                    tagOrderChoiceHandler.handler = \"changeLayout\";\r\n                   \r\n                    tagOrderChoiceHandler.customEventData = this.getPermutationByTagDegree(tagOrderList[i]).join(\",\");\r\n                    // this.tagOrderChoiceBtnList.push(tagOrderBtn);\r\n                \r\n                    tagOrderBtn.getComponent(Button).clickEvents.push(tagOrderChoiceHandler);\r\n                \r\n                    \r\n                }\r\n\r\n       }\r\n       catch(error){\r\n        console.log(error);\r\n       }\r\n        this.tagOrderChoiceBar.node.active = true;\r\n\r\n    }\r\n\r\n    private getPermutationByTagDegree(firstElement: string){\r\n        let tagOrderList = new Array<string>();\r\n        let dic = Manager.Instance().relationManager.tagDegreeDic;\r\n        let arr = Object.keys(Manager.Instance().relationManager.tagDegreeDic);\r\n        \r\n        tagOrderList.push(firstElement);\r\n        for(let i = 0; i < arr.length; i++){\r\n            if(arr[i] == firstElement) continue;\r\n             for(let j = 0; j < arr.length - 1; j++)\r\n             {\r\n                const key1 = arr[i];\r\n                const key2 = arr[j];\r\n                if(dic[key1] > dic[key2]){\r\n                    [arr[i], arr[j]] = [arr[j],arr[i]];\r\n                }\r\n             }\r\n        }\r\n        \r\n        \r\n        for(let tag of arr){\r\n            if(tag != firstElement)\r\n                tagOrderList.push(tag);\r\n            \r\n        }\r\n        //console.log(\"tagOrderList:\",tagOrderList)\r\n        return tagOrderList;\r\n    }\r\n\r\n\r\n    /**\r\n     * get the all the permutation of tags\r\n     * @param input \r\n     * @param current \r\n     * @param result \r\n     * @returns \r\n     */\r\n    private generatePermutations(input, current, result) {\r\n        \r\n        if (current.length === input.length) {\r\n            result.push(current.slice()); \r\n            return;\r\n        }\r\n        for (let i = 0; i < input.length; ++i) {\r\n\r\n            if (!current.includes(input[i])) {\r\n                current.push(input[i]);\r\n                this.generatePermutations(input, current, result);\r\n                current.pop();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * check the mouse leave on btn\r\n     */\r\n    private onLayoutBtnMouseLeave(event:EventMouse){\r\n        let mouseIn = false;\r\n       \r\n        if (this.timer) {\r\n            clearTimeout(this.timer);\r\n        }\r\n        \r\n\r\n        // set new timer to check if mouse enter tagOrderChoiceBar blockB\r\n        this.timer = setTimeout(() => {\r\n            if (!this.isEnteredTagOrderChoiceBar) {\r\n                \r\n                this.tagOrderChoiceBar.node.active = false;\r\n            }\r\n        }, 0.3);\r\n        \r\n    }\r\n\r\n    // private onTagOrderChoiceBtnClick(tagOrderString: string){\r\n        \r\n    //     //this.finalTagOrder = tagOrderString.split(\",\");\r\n    //     this.tagOrderChoiceBar.node.active = false;\r\n    //     this.dropDownBarLayout.node.active = false;\r\n        \r\n    // }\r\n\r\n    private cleanTagOrderChoices(){\r\n        this.isEnteredTagOrderChoiceBar = false;\r\n        if(this.tagOrderChoiceBar.node.children == null) return;\r\n        for(let child of this.tagOrderChoiceBar.node.children){\r\n            this.tagOrderChoiceBtnList = new Array<Node>();\r\n            child.destroy();\r\n        }\r\n    }\r\n    \r\n\r\n    /**\r\n     * set vertex ID Label for each vertex\r\n     * @param vertex: Vertex\r\n     */\r\n    public setVeretxIDLabel(vertex: Vertex){\r\n        // const vertexIDLabel = instantiate(this.vertexIDLabelPrefab);\r\n        // vertexIDLabel.setWorldPosition(vertex.node.worldPosition.x + 0.5, vertex.node.worldPosition.y + 1.5, 0);\r\n        // vertexIDLabel.getComponent(Label).string = vertex.vid;\r\n    }\r\n    \r\n}\r\n\r\n","import { _decorator, CCBoolean, CCInteger, CCString, Component, FixedJoint2D, Label, MeshRenderer, Node } from 'cc';\r\nimport { Manager } from './Manager';\r\nimport { Edge } from './Edge';\r\nconst { ccclass, property } = _decorator;\r\n\r\n@ccclass('Vertex')\r\nexport class Vertex extends Component {\r\n\r\n    @property(CCString)\r\n    public vid: string = \"\";\r\n    @property([CCString])\r\n    public tags: [string];\r\n    @property(Object)\r\n    public properties: Object =  new Object;\r\n    @property(CCString)\r\n    public type:string = \"vertex\";\r\n\r\n    @property(Number)\r\n    public degree:number = 0;\r\n\r\n    @property(Boolean)\r\n    public isLayouted = false;\r\n\r\n    @property({type:[Edge]})\r\n    public edgesSetOfVertex:Edge[] = [];\r\n\r\n    private idLabel = null;\r\n\r\n    @property(CCBoolean)\r\n    public isClicked:false; // if the vertex is clicked once\r\n\r\n    \r\n    protected onLoad(): void {\r\n        this.idLabel = this.node.getChildByName(\"ID\").getComponent(Label);\r\n        //console.log(\"id node:\",this.idLabel)\r\n    }\r\n    /**\r\n     * 0 -- current material\r\n     * 1 -- focus material\r\n     * 2~ --  random initial material\r\n     */\r\n    @property(CCInteger)\r\n    public materialCode = 2; //\r\n\r\n    // @property(Boolean)\r\n    // public isFocus:false;\r\n\r\n    /**\r\n     * set the attribute of vertex by JSON Object\r\n     * @param attribute \r\n     */\r\n    public setAttribute(attribute: any) {\r\n        //Manager.Instance().relationManager.popLastVertex();\r\n        if(this.vid != \"\"){\r\n            Manager.Instance().relationManager.removeVertex(this.vid);\r\n            \r\n        }\r\n         //Manager.Instance().relationManager.popLastVertex();\r\n\r\n        for (let key in attribute) {\r\n            if (this.hasOwnProperty(key)) {\r\n                this[key] = attribute[key];\r\n            }\r\n        }\r\n        Manager.Instance().relationManager.setVertexID(this.vid);\r\n        for(let tag of this.tags){\r\n            Manager.Instance().vertexManager.addTag(tag);\r\n        }\r\n        //console.log(\"vid:\",this.vid)\r\n        //console.log(\"idlabel:\",this.idLabel)\r\n        this.idLabel.string = this.vid;\r\n       \r\n    }\r\n\r\n    public setWorldPosition(entry: Node){\r\n        this.node.setWorldPosition(entry.worldPosition);\r\n    }\r\n\r\n\r\n    /**\r\n     * for those create vertex without certain vid\r\n     * then set vid by random \r\n     */\r\n    public setVertexId(){\r\n        // console.log(\"Manager.Instance().relationManager:\",Manager.Instance().relationManager);\r\n        this.vid = Manager.Instance().relationManager.setVertexID();\r\n        //this.idLabel.string = this.vid;\r\n        //console.log(\"set vertex id:\", this.vertexId);\r\n    }\r\n\r\n\r\n    public getVertexID(){\r\n        //console.log(\"vertex id:\",this.vertexId);\r\n        return this.vid;\r\n    }\r\n\r\n    public returnToInitialMaterial(){\r\n        let initialMaterial = this.getComponent(MeshRenderer).getMaterial(this.materialCode);\r\n        this.getComponent(MeshRenderer).setMaterial(initialMaterial, 0);\r\n    }\r\n\r\n    public setMaterialCode(code:number){\r\n        this.materialCode = code;\r\n    }\r\n\r\n    /**\r\n     * change material \r\n     * @param materialIndex: the code of changed material \r\n     */\r\n    public changeMaterial(materialIndex:number){\r\n        let tmpMaterial = this.getComponent(MeshRenderer).getMaterial(materialIndex);\r\n        this.getComponent(MeshRenderer).setMaterial(tmpMaterial, 0);\r\n    }\r\n\r\n    public getMaterialCode(){\r\n        return this.materialCode;\r\n    }\r\n\r\n    /**\r\n     * present the details of vertex\r\n     */\r\n    public showVertexDetails(){\r\n        //console.log(\"show detail Vertex ID:\"+this.vid);\r\n        \r\n        //console.log(\"tag:\",this.tags);\r\n        Manager.Instance().UIManager.nodeInfoBar.active = true;\r\n        Manager.Instance().UIManager.setRichInfo(\"Vertex vid:\"+this.vid);\r\n        Manager.Instance().UIManager.addRichInfo(\"tag:\"+this.tags);\r\n        \r\n        this.printNestedJSON(this.properties,\"properties\");\r\n        \r\n    }\r\n\r\n    public addEdgeInfoOnVertex(edge:Edge){\r\n        \r\n        this.edgesSetOfVertex.push(edge);\r\n        Manager.Instance().vertexManager.vertexEdgeDic[this.vid].push(edge.getEdgeID());\r\n    }\r\n    \r\n    private printNestedJSON(obj, parentKey = '') {\r\n        for (let key in obj) {\r\n          let newKey = parentKey ? `${parentKey}.${key}` : key;\r\n          if (typeof obj[key] === 'object' && obj[key] !== null) {\r\n            this.printNestedJSON(obj[key], newKey);\r\n          } else {\r\n                Manager.Instance().UIManager.addRichInfo(key+\": \"+obj[key]);\r\n          }\r\n        }\r\n   }\r\n\r\n   public increaseVertexDegree(){\r\n    this.degree++;\r\n    //console.log(\"vertex:\",vid,\" number:\",this.vertexDegreeDic[vid])\r\n}\r\n\r\n}\r\n\r\n","import { _decorator, Component, Prefab, instantiate, Node, Vec3,Quat, MeshRenderer } from 'cc';\r\nimport { Manager } from './Manager';\r\nimport { Vertex } from './Vertex';\r\nimport { Edge } from './Edge';\r\nconst { ccclass, property } = _decorator;\r\n\r\n@ccclass('VertexManager')\r\nexport class VertexManager extends Component {\r\n\r\n    node: Node;\r\n    // @property(Vec3)\r\n    // offset:Vec3 = new Vec3(-4,4,4);\r\n\r\n    isTransformView:boolean = false;\r\n\r\n    @property(Node)\r\n    rootNode:Node;\r\n\r\n    @property(Node)\r\n    public currentCentralNode:Node;\r\n\r\n    @property(Node)\r\n    chosenVertex:Node = null;\r\n\r\n    @property({ type: Prefab })\r\n    public vertexPrefab: Prefab = null;\r\n\r\n    @property\r\n    public vertexRadius;\r\n\r\n    /**\r\n     * store the {vertex1:[edge1,edge2], vertex2:[edge3,edge4]}\r\n     */\r\n    public vertexEdgeDic : {[key:string]:any[]} = {}\r\n\r\n    private vertexMaterialCount = 5;\r\n\r\n    /**\r\n     * Container of vertex's tags\r\n     */\r\n    public vertexTagSet: Set<string> = new Set<string>();\r\n\r\n\r\n\r\n\r\n    protected onLoad(): void {\r\n        this.rootNode =  this.node.getChildByName(\"CentralVertexOfCamera\");\r\n        this.vertexRadius = 30;\r\n        this.vertexTagSet = new Set<string>();\r\n        \r\n    }\r\n\r\n    protected start(): void {\r\n       \r\n        \r\n    }\r\n\r\n    /**\r\n     * \r\n     * @returns Node, the vertex is vertex.getCompoent(Vertex)\r\n     */\r\n    public createStartNode():Node{\r\n        const vertex = instantiate(this.vertexPrefab); // initial the prefab\r\n        vertex.getComponent(Vertex).setVertexId(); //set id\r\n        let initialMaterialCode =  Math.floor(Math.random() * (this.vertexMaterialCount)) + 2; // get the random material code\r\n        vertex.getComponent(Vertex).setMaterialCode(initialMaterialCode);\r\n        vertex.getComponent(Vertex).changeMaterial(initialMaterialCode);\r\n        // let tmpMaterial = vertex.getComponent(Vertex).getComponent(MeshRenderer).getMaterial(initialMaterialCode);\r\n        // vertex.getComponent(Vertex).getComponent(MeshRenderer).setMaterial(tmpMaterial, 0); // set the random material\r\n\r\n        const randomDirection = new Vec3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();\r\n        const randomOffset = randomDirection.clone().multiplyScalar(this.vertexRadius); // set the random position of node\r\n        \r\n        // \r\n        const position = randomOffset.add(Manager.Instance().vertexManager.currentCentralNode.worldPosition); // set the currentCentralNode as center\r\n        vertex.worldPosition = position;\r\n        // vertex.setParent(node);\r\n        vertex.setParent(Manager.Instance().vertexManager.rootNode);\r\n        this.vertexEdgeDic[vertex.getComponent(Vertex).getVertexID()] = []; // set id\r\n        //console.log(\"create vertexEdgeDic of:\",vertex.getComponent(Vertex).getVertexID()+\"dic:\",this.vertexEdgeDic);\r\n\r\n        return vertex;\r\n    }\r\n\r\n\r\n    /**\r\n     * create end node around parent node when click the start node\r\n     * @param node the parent node\r\n     * @returns \r\n     */\r\n    public createNodeAround(node: Node) {\r\n        const vertex = instantiate(this.vertexPrefab); // initial the prefab\r\n\r\n        vertex.getComponent(Vertex).setVertexId();\r\n        \r\n        let initialMaterialCode =  Math.floor(Math.random() * (this.vertexMaterialCount)) + 2; // get the random material code\r\n        \r\n        vertex.getComponent(Vertex).setMaterialCode(initialMaterialCode);\r\n        vertex.getComponent(Vertex).changeMaterial(initialMaterialCode);\r\n        // let tmpMaterial = vertex.getComponent(Vertex).getComponent(MeshRenderer).getMaterial(initialMaterialCode);\r\n        // vertex.getComponent(Vertex).getComponent(MeshRenderer).setMaterial(tmpMaterial, 0); // set the random material\r\n\r\n        // const randomDirection = new Vec3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();\r\n        // const randomOffset = randomDirection.clone().multiplyScalar(this.vertexRadius);\r\n        const randomDirection = new Vec3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();\r\n        const randomOffset = randomDirection.clone().multiplyScalar(this.vertexRadius);\r\n        \r\n        // \r\n        const position = randomOffset.add(node.worldPosition);\r\n        vertex.worldPosition = position;\r\n        // vertex.setParent(node);\r\n        vertex.setParent(Manager.Instance().vertexManager.rootNode);\r\n        this.vertexEdgeDic[vertex.getComponent(Vertex).getVertexID()] = []; // set id\r\n        \r\n\r\n\r\n        // vertex.getComponent(Vertex).setVertexId();\r\n        // vertex.setParent(this.node);\r\n        return vertex;\r\n    }\r\n\r\n    /**\r\n     * click one vertex and choose this vertex as potential focus\r\n     * call it when click it once\r\n     * @param chosenNode \r\n     */\r\n    public chooseOneNormalVertexToFocus(chosenNode:Node){\r\n        this.chosenVertex = chosenNode;\r\n        // this.currentCentralNode = chosenNode;\r\n        let focusMaterial = this.chosenVertex.getComponent(Vertex).getComponent(MeshRenderer).getMaterial(1);\r\n        this.chosenVertex.getComponent(Vertex).getComponent(MeshRenderer).setMaterial(focusMaterial, 0);\r\n    }\r\n\r\n    public returnFocusToNormalVertex(){\r\n        \r\n        if(!this.chosenVertex) return;\r\n        this.chosenVertex.getComponent(Vertex).returnToInitialMaterial();\r\n        this.chosenVertex = null;\r\n        Manager.Instance().UIManager.cleanAndDisableInfoBar();\r\n\r\n    }\r\n\r\n    /**\r\n     * get the Node of vertex by name\r\n     * @param vertexID \r\n     * @returns Node\r\n     */\r\n    public getVertexNodeByVID(vertexID:String):Node{\r\n        for(let child of this.rootNode.children){\r\n            if(child.getComponent(Vertex).vid == vertexID) return child;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * add type to Set\r\n     * @param type \r\n     */\r\n    public addTag(type:string){\r\n        // vertexTypeSet doesn't have this type\r\n        if(!this.vertexTagSet.has(type)){\r\n            this.vertexTagSet.add(type); // add this type\r\n        }\r\n    }\r\n\r\n    public removeLayoutFlags(){\r\n        \r\n        this.traverseNodesChildren(this.rootNode)\r\n        //let parents = this.rootNode;\r\n        // for(let child of parents.children){\r\n        //     if(child.children != null){\r\n        //         console.log(\"parent:\",parents,\" child:\",child);\r\n        //         parents = child;\r\n\r\n        //     }\r\n        //     else{\r\n        //         console.log(\"node name:\",child.name);\r\n        //         child.getComponent(Vertex).isLayouted = false;\r\n                \r\n        //     }\r\n        // }\r\n    }\r\n\r\n    private traverseNodesChildren(node: Node){\r\n        \r\n        if(node.getComponent(Vertex) != null){\r\n            node.getComponent(Vertex).isLayouted = false;\r\n        }\r\n        if(node.children == null) return;\r\n        for(let child of node.children){\r\n            this.traverseNodesChildren(child);\r\n        }\r\n\r\n\r\n    }\r\n\r\n    /**\r\n     * delete all the children of veretxManager\r\n     */\r\n    public destroyAllChildren(){\r\n        //console.log(\"root node:\",this.rootNode);\r\n        this.rootNode.children.forEach((child) => {\r\n            child.destroy();\r\n        });\r\n        this.rootNode.removeAllChildren();\r\n        // this.node.children.forEach((child) => {\r\n        //     child.destroy();\r\n        // });\r\n        // this.node.removeAllChildren();\r\n        Manager.Instance().relationManager.resetVertexAndEdgeBox();\r\n        this.rootNode.position = new Vec3(0, 0, 0);\r\n        this.rootNode.rotation =  Quat.identity(new Quat());\r\n        this.currentCentralNode = this.rootNode;\r\n        this.returnFocusToNormalVertex();\r\n    }\r\n\r\n    /**\r\n     * do the initiation\r\n     */\r\n    public initiateOriginalVertex(){\r\n        const vertex = instantiate(this.vertexPrefab);\r\n\r\n        // this.centralNode.position = new Vec3(0, 0, 0);\r\n        // this.centralNode.rotation =  Quat.identity(new Quat());\r\n        vertex.getComponent(Vertex).setVertexId();\r\n        vertex.worldPosition = new Vec3(0,0,0);\r\n        vertex.setParent(this.rootNode);\r\n        \r\n        this.currentCentralNode =  vertex;\r\n    \r\n        // this.node.position = new Vec3(0, 0, 0);\r\n        // this.node.rotation =  Quat.identity(new Quat());\r\n        // vertex.getComponent(Vertex).setVertexId();\r\n        // vertex.worldPosition = new Vec3(0,0,0);\r\n        // vertex.setParent(this.node);\r\n        // this.centralNode = vertex;\r\n    }\r\n\r\n\r\n\r\n\r\n}"]}